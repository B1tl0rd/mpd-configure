#!/usr/bin/env bash
##
## `mpd-configure' is a bash script that tries to ease the
## configuration of mpd for audiophile purposes.
##
##  Copyright (C) 2015 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## The script, helpers and documentation are published at 
## https://github.com/ronalde/mpd-configure
## 
## Also see `README'

LANG=C
APP_NAME_MPDCONFIGURE="mpd-configure"
APP_URL="https://github.com/ronalde/${APP_NAME_MPDCONFIGURE}/"
# version gets filled by sourcing alsa-capabilities
APP_VERSION="${APP_VERSION:-0.8}"

### defaults
## default network address to listen to
CONF_MPD_NETWORK_ADRESS_DEFAULT="0.0.0.0"
## default network port to listen on
CONF_MPD_NETWORK_PORT_DEFAULT="6600"
## default maximum number of files in music directory
MAX_PLAYLIST_LENGTH_DEFAULT="16384"


function die_configure() {
    printf "\nError in %s (v%s):\n%s\n" \
	   "${APP_NAME_MPDCONFIGURE}" "${APP_VERSION}" "$@" 1>&2;
    exit 1
}

function debug_configure() {
    printf "DEBUG %s *** %s.\n"  "${APP_NAME_MPDCONFIGURE}" "$@" 1>&2;
}

function debug_function() {
    printf "DEBUG %-18s:\n" "${APP_NAME_MPDCONFIGURE}" 1>&2;
    printf "\tentering function \`%s',\n" "$1" 1>&2;
    printf "\twith arguments \`%s'.\n" "$2" 1>&2;
}


function really_write() {
    ## writes the contents of CONF_CONTENTS to the file specified in $1.
    ## returns success or error with descriptive string
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    mpd_conffile="$1"
    ## do the actual writing
    #debug_configure "${CONF_CONTENTS}"
    res="$(echo -e "${CONF_CONTENTS}" > "${mpd_conffile}")"
    if [[ $? -ne 0 ]]; then
	## return an error with descriptive message
	printf "Could not write to \`%s'" "${mpd_conffile}"
	return 1
    else
	## return the result
	printf "\ndone! mpd configuration successfully file saved in \`%s'.\n" \
	       "${mpd_conffile}"
    fi
}

function check_or_create_targetdir() {
    ## checks if the parent directory for target mpd configuration $1
    ## exists and is writable, otherwise attempts to create
    ## it.
    ## returns success or an error with descriptive string.
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    mpd_conf_file="$1"
    mpd_conf_dir="$(dirname "${mpd_conf_file}")"
    errors=()
    
    if [[ ! -d "${mpd_conf_dir}" ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "conf dir \`${mpd_conf_dir}' does not exist, try to create it"
	res="$(mkdir -p "${mpd_conf_dir}" 2>&1)"
	if [[ $? -ne 0 ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "error creating mpd_conf_dir \`${mpd_conf_dir}': \`${err}'"
	    printf " %s can't create parent directory \`%s'.\n" \
		   "-" "${mpd_conf_dir}"
	    return 1
	else
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "successfully created mpd_conf_dir \`${mpd_conf_dir}'"
	    printf "%s" "${mpd_conf_dir}"
	fi
    else
	[[ ! -z ${DEBUG} ]] && \
		debug_configure "mpd_conf_dir \`${mpd_conf_dir}' already exists"
	## conf dir exists, check if it writable
	if [[ ! -w "${mpd_conf_dir}" ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "mpd_conf_dir \`${mpd_conf_dir}' already exists"
	    printf " - no write permission in target directory \`%s'." "${mpd_conf_dir}"
	    return 1
	else
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "conf dir \`${mpd_conf_dir}' is writable"
	    printf "%s" "${mpd_conf_dir}"
	fi
    fi
}

function check_existing_conffile() {
    ## checks if target mpd configuration file $1 exists and is
    ## writable.
    ## returns success or an error with descriptive string.
    mpd_conf_file="$1"
    if [[ -f "${mpd_conf_file}" ]]; then
	if  [[ ! -w "${mpd_conf_file}" ]]; then
	    ## not writable, exit with error 
	    printf " %s existing file \`%s' is present, but is not writable.\n" \
		   "-" "${mpd_conf_file}"
	    return 1
	else
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "conffile \`${mpd_conf_file}' exists and is writable"
	    ## return the path to indicate it does exits and is writable
	    printf "%s" "${mpd_conf_file}"
	fi
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "conffile \`${mpd_conf_file}' does not exist"
	## return success (but no path)
	return 0
    fi
}

function make_temp_conf() {
    ## makes a temporary file for storing the mpd configuration file.
    ## returns the path to the created file or error.
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    ## try to make a temp file in /tmp 
    tempfile="$(mktemp -p /tmp mpd.XXXX.conf)"
    if [[ $? -ne 0 ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "Unable to create a temporary file \`${tempfile}'"
	printf "  %s unable to create a temporary file \`%s'\n" \
	       "-" "${tempfile}" 1>&2;
	# TODO: print to std_out
	die "Unable to create a temporary file \`${tempfile}'"
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "temporary file \`${tempfile}' created"
	printf " %s will store it in a temporary file instead.\n"\
	       "-" 1>&2;
	## set a new target path 
	mpd_conf_file="${tempfile}"
	printf "%s" "${mpd_conf_file}"
    fi
}

function backup_original_conf() {
    ## create a backup of the current config file $1
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"
    
    mpd_conf_file="$1"

    if [[ ! -z ${TEMP_CONF_BACKUP} ]]; then
	if [[ -f "${TEMP_CONF_BACKUP}" ]]; then
	    printf "TEMP_CONF_BACKUP specified to \`%s' but already exists; not overwriting." \
		   "${TEMP_CONF_BACKUP}"
	    return 1
	fi
    else 
	TEMP_CONF_BACKUP="$(mktemp -p /tmp ${mpd_conf_file##*/}.XXXX)"
	if [[ $? -ne 0 ]]; then
	    printf "error creating a temporary file which should hold the backup."
	    return 1
	else
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "will create backup in \`${TEMP_CONF_BACKUP}'."
	fi
    fi
    res="$(cp -av "${mpd_conf_file}" "${TEMP_CONF_BACKUP}")"
    if [[ $? -ne 0 ]]; then
	## error creating a backup with copy
	printf "${res}"
	return 1
    else	    
	printf "%s" "${TEMP_CONF_BACKUP}"
    fi
    
    
}



function write_conffile() {
    ## prepares to write to the target mpd configuration file specified by $1.
    ## returns success or an error with descriptive string.
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    declare -a errors
    error_message=""
    mpd_conf_file="$1"
    existing_file=
    mpd_confdir=""
    maketemp=
    existing_file="$(check_existing_conffile "${mpd_conf_file}")"
    ## check if the file exists
    if [[ $? -ne 0 ]]; then
	## the file exists but is not writable
	maketemp="${existing_file}"
    else
	if [[ -z "${existing_file}" ]]; then
	    ## new file, check the (parent) path
	    target_dir_writable="$(check_or_create_targetdir "${mpd_conf_file}")"
	    if [[ $? -ne 0 ]]; then 
		maketemp="${target_dir_writable}"
	    fi
	fi
    fi

    if [[ ! -z ${maketemp} ]]; then
	## either existing file or new target directory is not writable
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "can't write to target file \`${mpd_conf_file}': \`${maketemp}'"
	printf "\nError: unable to write to %s \`%s':\n" \
	       "${MSG_MPD_CONFFILE}" "${mpd_conf_file}" 1>&2;
	printf "%s\n" "${maketemp}" 1>&2;
	mpd_conf_file="$(make_temp_conf)"
    else 
	## only prompt when OVERWRITE_EXISTING_CONFFILE is not set
	if [[ ! -z ${existing_file} ]]; then
	    printf " %s existing %s found in \`%s':\n" \
		   "-" "${MSG_MPD_CONFFILE}" "${mpd_conf_file}" 1>&2;
	    [[ ! -z "${DEBUG}" ]] && \
		debug_configure "OVERWRITE_EXISTING_CONFFILE: \`${OVERWRITE_EXISTING_CONFFILE}'"
	    if [[ ! -z ${OVERWRITE_EXISTING_CONFFILE} ]]; then
		printf "     user requested overwriting of original conf file.\n" 1>&2;
	    else 
		prompt="     overwrite it (while making a backup of the original)?: "
		overwrite="$(read -e -p "${prompt}" -i "Yes" \
overwrite && echo -e "${overwrite}")"
		## if prompt returns (downcased) `yes' then overwrite the file
		if ! [[ "${overwrite,,}" =~ yes ]]; then
		    ## user chose no to overwrite; try to save in temporary file, otherwise
		    ## exit with message
		    printf "\nNot overwriting existing %s \`%s'.\n" \
			   "${MSG_MPD_CONFFILE}" "${mpd_conf_file}" 1>&2;
		    mpd_conf_file="$(make_temp_conf)"
		else
		    temp_backup_file="$(backup_original_conf "${mpd_conf_file}")"
		    if [[ $? -ne 0 ]]; then
			printf "could not create backup of \`%s' (%s).\n" \
			       "${mpd_conf_file}" "${temp_backup_file}" 1>&2;
			printf "will print config to stdout instead.\n" 1>&2;
			return 1
		    else
			printf " %s backup of existing %s created in \`%s'\n" \
			       "-" "${MSG_MPD_CONFFILE}" "${temp_backup_file}" 1>&2;
		    fi

		fi
	    fi
	fi
    fi
    ## do the actual writing
    fileok="$(really_write "${mpd_conf_file}")"
    if [[ $? -ne 0 ]]; then
	die "unspecified error"
    else
	printf " %s done ... the resulting %s is saved in:\n" \
	       "-" "${MSG_MPD_CONFFILE}" 1>&2;
	## return the resulting file to the calling function
	printf "%s" "${mpd_conf_file}"
    fi 

}


function command_not_found() {
    ## give installation instructions when a command is not available
    ## and exit with error,
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    command="$1"
    package="$2"
    instructions="$3"
    msg="Error: command \`${command}' not found. "

    [[ -z "${instructions}" ]] && \
	msg+="Users of Debian (or deratives, like Ubuntu) can install it with: \
\n sudo apt-get install ${package}" || \
	msg+="${instructions}"

    die_configure "${msg}"

}

function fetch_alsa_hwaddresses() {
    ## use alsa-capabilities script to get alsa output interfaces; if
    ## one interface is found, use that, otherwise display all of them
    ## and ask the user which to use.
    ##
    ## stores the hardware address and label in global variables
    ## ALSA_AIF_HWADDRESS and ALSA_AIF_DEVLABEL.
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"
    
    ## when more than one matching output device is found and
    ## DISABLE_PROMPTS is not set, prompt the user to select one,
    ## otherwise use the first device found.
    prompt_messages=()
    selected_key=0
    
    ## call alsa-capabilities for filling up the array ALSA_AIF_HWADDRESSES
    return_alsa_interface
    if [[ $? -ne 0 ]]; then
	## something went wrong in return_alsa_interface
	printf "Error getting results from \`return_alsa_interface'.\n" 1>&2;
	return 1
    else
	interface_count=${#ALSA_AIF_HWADDRESSES[@]}
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "number of returned alsa interfaces: \`${interface_count}'."
	case ${interface_count} in
	    0)
		printf "\`return_alsa_interface' returned zero (0) interfaces.\n" "${res}" 1>&2;
		return 1
		;;
	    1)
		## single interface found; use it
		selected_key=0
		;;
	    *)
		## multiple interfaces found; prompt the user or use
		## the first one if DISABLE_PROMPTS is set
		if [[ ! -z "${DISABLE_PROMPTS}" ]]; then
		    printf " %s multiple interfaces found, but user set DISABLE_PROMPTS,\n" \
			   "-" 1>&2;
		    printf "     therefore will use the first one found (${ALSA_AIF_HWADDRESSES[0]}).\n" \
			   "-" 1>&2;

		    selected_key=0
		else
		    ## display instructions for multiple interfaces and prompt
		    ## to use that of the first available interface
		        ## prompt when multiple alsa interfaces are found
		    prompt_messages+=("Multiple interfaces found:")

		    default_aif_hwaddress="${ALSA_AIF_HWADDRESSES[0]}"
		    prompt_messages+=("   specify the hardware address of the interface you wish to use")
		    prompt_messages+=("   for mpd and press [ENTER] to confirm: ")
		    ## format the message
		    prompt="$(printf "  %s\n" "${prompt_messages[@]}")"
		    ## prompt the user to select a interface
		    alsa_aif_hwaddress="$(read -e -p "${prompt}" \
-i "${default_aif_hwaddress}" alsa_aif_hwaddress && \
echo -e "${alsa_aif_hwaddress}")"

		    [[ ! -z ${DEBUG} ]] && \
			debug_configure "user entered \`${alsa_aif_hwaddress}'."
		    for key in "${!ALSA_AIF_HWADDRESSES[@]}"; do
			## set the user selected key and exit loop
			if [[ "${ALSA_AIF_HWADDRESSES[$key]}" = "${alsa_aif_hwaddress}" ]]; then
			    let selected_key=${key}
			    break
			fi
		    done

		    ## handle empty or invalid input
		    msg=""
		    if [[ "${ALSA_AIF_HWADDRESSES[$selected_key]}" \
			      != "${alsa_aif_hwaddress}" ]]; then
			prompt_messages=("  NOTE:")			
			if [[ -z ${alsa_aif_hwaddress} ]]; then
			    [[ ! -z ${DEBUG} ]] && \
				debug_configure "no hwaddress entered"
			    msg="no hardware address "
			else
			    [[ ! -z ${DEBUG} ]] && \
				debug_configure "an invalid hwaddress \`${alsa_aif_hwaddress}' entered"
			    msg="an invalid hardware address (${alsa_aif_hwaddress})"
			fi
			prompt_messages+=("     Because ${msg} was entered, the script will use")
			prompt_messages+=("     the first available audio interface: \`${ALSA_AIF_HWADDRESSES[${selected_key}]}'")
			prompt_messages+=("  Please press [ENTER] to continue")
			prompt="$(printf "%s\n" "${prompt_messages[@]}")"
			res="$(read -e -p "${prompt}")"
		    else
			[[ ! -z ${DEBUG} ]] && \
			    debug_configure "chosen key \`${selected_key}' for \
interface \`${ALSA_AIF_HWADDRESSES[${selected_key}]}'"
		    fi
		fi
		;;	
	esac
    fi

    ## store the hardware address and label for usage in audio_conf
    CONF_ALSA_AIF_HWADDRESS="${ALSA_AIF_HWADDRESSES[${selected_key}]}"
    CONF_ALSA_AIF_DEVLABEL="${ALSA_AIF_DEVLABELS[${selected_key}]} - \
${ALSA_AIF_LABELS[${selected_key}]}"

}


function check_readable_path() {
    ## checks if path ($1), needed for ($2) is readable, or adds
    ## problem description ($2) to problems array.
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n  - can't access or read ${purpose} \`${path}',\
\n   you won't be able to ${problem}.\n"
    [[ -d "${path}" || -f "${path}" ]] || PROBLEMS+=("${msg}") 
}


function check_writeable_path() {
    ## checks if path ($1), needed for ($2) is writeable, or adds
    ## problem description ($2) to problems array.
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n  - can't write to ${purpose} \`${path}',\
\n   you won't be able to ${problem}.\n"

    [[ -w "${path}" ]] || PROBLEMS+=("${msg}") 
}

function parse_configuration_line() {
    ## parse a line from mpd configuration templates, replacing
    ## variables in those templates with values from this scripts
    ## configuration files and returning them to the calling function.
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    line="$@"

    ## construct the regular expression for configuration items
    local brm='([[:alpha:][:alnum:]_]*)[[:space:]]*\"\$\{(.*)\}\"$'
    ## match the regexp
    if [[ "${line}" =~ ${brm} ]] ; then
	## line is mpd configuration: `config_value "${...}"'
	
	## given a line of `config_value "${...}"'
	## the name of the variable with or without a default value: `...'
	var_part="${BASH_REMATCH[2]}"
	var_template="${var_part}"
	var_search="${var_template}"
	if [[ "${var_part}" =~ ^(.*):-(.*)$ ]]; then
	    ## the line contains a variable with default value:
	    ##  `config_value "${VARNAME:-default_value}"'

	    ## store the variable name: `VARNAME'
	    var_template="${BASH_REMATCH[1]}"
	    var_value="${BASH_REMATCH[2]}"
	    ## the variable name including its default value `VARNAME:-default_value'
	    var_search="${BASH_REMATCH[1]}:-${BASH_REMATCH[2]}"
	fi
	## assign the name of the variable (`VARNAME') to $expanded_name
	exp_name=var_template
	## assign the value of the variable (`$VARNAME') to $expanded_value
	local exp_value="${!exp_name}"
	## return the line with its real/expanded value
	if [[ ! -z "${!exp_value}" ]]; then
	    printf "%s" "${line//\$\{${var_search}\}/${!exp_value}}"
	else
	    [[ -z ${INCLUDE_COMMENTS} ]] && \
		printf "" || \
		printf "# %s (value not set)" "${line//\$\{${var_search}\}/${!exp_value}}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug_configure "not writing empty configuration setting \`${var_template}'."
	fi
    else
	## a normal line; return it
	printf "%s" "${line}"
    fi
    
}

function source_enabled_confs() {
    ## source conf snippets in ./confs-enabled/*.conf while
    ## substituting the variables in those conf files with the ones
    ## generated in this script.
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    ## temporary file needed to source enabled configuration snippets files
    tempconfs="$(mktemp)"
    ## fill the file with all configuration lines from `confs-enabled/*.conf`
    sed 's/^\([[:alnum:][:space:]_]*\)[[:space:]]*"\${\(.*\):-\(.*\)}"$/export \2="\${\2:-\3}"/' \
	${SCRIPT_DIR}/confs-enabled/*.conf | grep -E ^export > "${tempconfs}"
    ## source it (needed for variable expansion)
    source "${tempconfs}" || die_configure "could not source \`${tempconfs}'"
    ## remove it when DEBUG_CONFIGURE is not set
    [[ ! -z "${DEBUG}" ]] && \
	debug_configure "sourced configuration values stored in \`${tempconfs}'.\n" || \
	rm "${tempconfs}"

    ## iterate each file
    for conf_file in ${CONFS_ENABLED}; do
	## check if the symlink points to a valid file
	isvalid="$(readlink -e "${conf_file}")"
	## process the next one if the symlink is broken 
	if [[ -z "${isvalid}" ]]; then
	    [[ ! -z "${DEBUG}" ]] && debug_configure "not a valid symlink \`${conf_file}'"
	    continue
	fi
	## the file exists, parse it
	printf "\n## start processing \`%s'\n" "${conf_file##*/}"
	## iterate each line
	while IFS='' read -r line ; do
	    ## skip commented lines
	    ## create trimmed version of line
	    if [[ -z ${INCLUDE_COMMENTS} ]]; then
		trimmed=$([[ "${line}" =~ [[:space:]]*([^[:space:]]|[^[:space:]].*[^[:space:]])[[:space:]]* ]]; echo -n "${BASH_REMATCH[1]}")
		if [[ "${trimmed#\#*}" = "${trimmed}" ]]; then
		    if [[ ! -z "${trimmed}" ]]; then
			## parse the line
			line="$(parse_configuration_line "${line}")"
			
			local interpreted_line="${!line}"
			## original code
			[[ ! -z "${line}" ]] && \
			    printf "%s\n" "${line}"
		    fi
		fi
	    else
		line="$(parse_configuration_line "${line}")"
		echo -e "${line}"
	    fi
	done <${conf_file}
	echo -e "## done processing"
    done
}

function perform_automagic() {
    ### automagic configuration stuff
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    ## client limits
    ## if the directory specified in `CONF_MPD_MUSICDIR` is
    ## accessible, calculate the number of audio files and double that
    ## for `max_playlist_length` parameter.
    
    default_length=${MAX_PLAYLIST_LENGTH_DEFAULT}
    nr_musicfiles=0

    if [[ -z ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "G_CLIENTLIMITS_MAXPLAYLISTLENGTH not set, trying to count the number of music files ..."
	## setting not configured
	if [[ -d "${CONF_MPD_MUSICDIR}" ]]; then
	    ## music dir exists; calculate number of files
	    ## TODO: add permission errors to errorlog
    	    ## ls without stat() calls is much faster than find or bash globbing, thanks 
	    ## http://stackoverflow.com/questions/1427032/fast-linux-file-count-for-a-large-number-of-files
	    let nr_musicfiles=$(ls -fR  "${CONF_MPD_MUSICDIR}" 2>/dev/null| wc -l)

	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Done counting, nr of files found: \`${nr_musicfiles}'"

	    let double_nr_musicfiles=( ${nr_musicfiles} * 2 )
	    [[ ${double_nr_musicfiles} -gt ${default_length} ]] && \
		G_CLIENTLIMITS_MAXPLAYLISTLENGTH=${double_nr_musicfiles} || \
		G_CLIENTLIMITS_MAXPLAYLISTLENGTH=${default_length}
	else
	    ## music dir not available; use default
	    G_CLIENTLIMITS_MAXPLAYLISTLENGTH=${default_length}
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Music dir not available, nr of files set to default: \`${G_CLIENTLIMITS_MAXPLAYLISTLENGTH}'."
	fi
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "G_CLIENTLIMITS_MAXPLAYLISTLENGTH set to \`${G_CLIENTLIMITS_MAXPLAYLISTLENGTH}'."

    fi
    
    ## if empty set `G_CLIENTLIMITS_MAXCOMMANDLISTSIZE` to 1/8 of
    ## `G_CLIENTLIMITS_MAXPLAYLISTLENGTH`
    [[ -z ${G_CLIENTLIMITS_MAXCOMMANDLISTSIZE} && \
	! -z ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} ]] && \
	let G_CLIENTLIMITS_MAXCOMMANDLISTSIZE=( ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} / 8 )
    
    ## if empty, set `MAXOUTPUTBUFFERSIZE` to 1/2 of
    ## `G_CLIENTLIMITS_MAXPLAYLISTLENGTH`
    [[ -z ${G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE} && \
	! -z ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} ]] && \
	let G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE=( ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} / 2 )
    
    if [[ ! -z "${DEBUG}" ]]; then
	debug_configure "G_CLIENTLIMITS_MAXPLAYLISTLENGTH: \`${G_CLIENTLIMITS_MAXPLAYLISTLENGTH}'"
	debug_configure "G_CLIENTLIMITS_MAXCOMMANDLISTSIZE: \`${G_CLIENTLIMITS_MAXCOMMANDLISTSIZE}'"
	debug_configure "G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE: \`${G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE}'"
    fi
    
    ## get network name for zeroconf
    if [[ -z "${G_ZEROCONF_ZEROCONFNAME}" ]]; then
	## `G_ZEROCONF_ZEROCONFNAME` is not set; set default zeroconf label 
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "G_ZEROCONF_ZEROCONFNAME not set  ..."
	
	hostname_string=""
	## only try to get hostname if it isn't link local
	if [[ ! "${CONF_MPD_NETWORK_ADRESS}" =~ "127" ]] || [[ "${CONF_MPD_NETWORK_ADRESS}" != "0.0.0.0" ]] || \
	    [[ ! "${CONF_MPD_NETWORK_ADRESS}" =~ "*::*"  ]]; then
	    ## mpd is configured to use a 'real' ip address; try to get fqdn name
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "mpd is configured to use a 'real' ip address ..."
	    if [[ -x $(which hostname) ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "hostname command is available"
		hostname="$(hostname --fqdn)"
		if [[ -z "${hostname}" ]]; then
		    ## fallback to 'short' hostname
		    hostname="$(hostname)"
		    [[ ! -z ${DEBUG} ]] && \
			debug_configure "mpd hostname set by script and hostname to short name \`${hostname}'."
		else
		    [[ ! -z ${DEBUG} ]] && \
			debug_configure "mpd hostname set by script and hostname to fqdn \`${hostname}'."
		fi
	    else
		# use bash's internal hostname
		hostname="${HOSTNAME}"
		[[ ! -z ${DEBUG} ]] && \
		    debug_configure "mpd hostname set by script to HOSTNAME variable of bash: \`${hostname}'."
	    fi
	else
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "G_ZEROCONF_ZEROCONFNAME set by user to \`${G_ZEROCONF_ZEROCONFNAME}'."

	fi
	
	## set string to use if hostname contains something
	[[ ! -z ${hostname} ]] && hostname_string="on ${hostname} "
	G_ZEROCONF_ZEROCONFNAME="${ZEROCONF_NAME:-MPD \
${hostname_string}through ${CONF_ALSA_AIF_DEVLABEL}}"
	
    fi

}

function get_mpd_musicdir() {
    ### get and check music dir
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    ## check if user set the music dir configuration parameters
    if [[ ! -z "${CONF_MPD_MUSICDIR}" ]]; then
        G_PATHS_MUSICDIRECTORY="${CONF_MPD_MUSICDIR}"
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_MUSICDIR set by user to \`${G_PATHS_MUSICDIRECTORY}'."
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_MUSICDIR not set by user ..."
        
	## try getting the `MUSIC' directory from XDG and use that,
	## otherwise user current dir
	CMD_XDGUSERDIR=$(which xdg-user-dir)
	if [[ $? -eq 0 ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "CMD_XDGUSERDIR found in path: \`${CMD_XDGUSERDIR}'."
	    xdg_music_dir="$(${CMD_XDGUSERDIR} MUSIC)"
	    if [[ "$?" -eq 0 ]]; then
		G_PATHS_MUSICDIRECTORY="${xdg_music_dir}"
		[[ ! -z ${DEBUG} ]] &&  \
		    debug_configure "G_PATHS_MUSICDIRECTORY set to xdg-music-dir (${G_PATHS_MUSICDIRECTORY})"
	    else
		[[ ! -z ${DEBUG} ]] &&  \
		    debug_configure "G_PATHS_MUSICDIRECTORY left empty (${G_PATHS_MUSICDIRECTORY})"
            fi
	else
	    if [[ ! -z ${DEBUG} ]]; then
		debug_configure "CMD_XDGUSERDIR not found in path."
		debug_configure "G_PATHS_MUSICDIRECTORY left empty (${G_PATHS_MUSICDIRECTORY})"
	    fi
	fi
    fi
    
    ## use current dir if still empty
    if [[ -z ${G_PATHS_MUSICDIRECTORY} ]]; then
      G_PATHS_MUSICDIRECTORY="$(pwd)"
      [[ ! -z ${DEBUG} ]] && \
	  debug_configure "G_PATHS_MUSICDIRECTORY set to current dir: \`${G_PATHS_MUSICDIRECTORY}'."
    fi 
   
    check_readable_path "${G_PATHS_MUSICDIRECTORY}" "music directory" "listen to music"
    
}

function get_mpd_homedir() {
    ### get and check working directory for mpd
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"
  
    ## if `CONF_MPD_HOMEDIR` not set by user use `XDG_CONFIG_MPDDIR`
    if [[ -z ${CONF_MPD_HOMEDIR} ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_HOMEDIR not set, trying to get xdg_config_dir ..."
       ## use user xdg config dir or current path
	XDG_CONFIG_DIR="${HOME}/.config"
	if [[ -d ${XDG_CONFIG_DIR} ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "XDG_CONFIG_DIR found: \`${XDG_CONFIG_DIR}'."
	else   
	    XDG_CONFIG_DIR=$(pwd)
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "XDG_CONFIG_DIR not found, using current dir: \`${XDG_CONFIG_DIR}'."
	fi
        ## set default path
	CONF_MPD_HOMEDIR=${XDG_CONFIG_DIR}/mpd
	[[ ! -z ${DEBUG} ]] && \
		debug_configure "CONF_MPD_HOMEDIR set by script to: \`${CONF_MPD_HOMEDIR}'."
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_HOMEDIR set by user to \`${CONF_MPD_HOMEDIR}'."
    fi
    
    ## check if it is accessible
    check_readable_path "${CONF_MPD_HOMEDIR}" "mpd home directory" \
	"use mpd"
    check_writeable_path "${CONF_MPD_HOMEDIR}" "mpd home directory" \
	"store mpd database, playlist and cache."
    
    ## where to store data
    MPD_DATADIR="${MPD_DATADIR:-${CONF_MPD_HOMEDIR}}"
    CONF_MPD_PLAYLISTDIR="${MPD_PLAYLISTDIR:-${MPD_DATADIR}/playlists}"
    check_readable_path "${MPD_PLAYLISTDIR}" "playlist directory" "use playlists"
    check_writeable_path "${MPD_PLAYLISTDIR}" "playlist directory" \
	"change or create playlists"
    CONF_MPD_DBFILE="${MPD_DBFILE:-${MPD_DATADIR}/tag_cache}"
    check_readable_path "${MPD_DBFILE}" "database file" "use mpd"
    check_writeable_path "${MPD_DBFILE}" "database file" "store changes in mpd"
    CONF_MPD_LOGFILE="${MPD_LOGFILE:-${MPD_DATADIR}/mpd.log}"
    check_writeable_path "${MPD_LOGFILE}" "log file" "start or use mpd"
    CONF_MPD_PIDFILE="${MPD_PIDFILE:-${MPD_DATADIR}/pid}"
    check_writeable_path "${MPD_PIDFILE}" "PID file" \
	"start, stop or restart mpd using service daemon"
    CONF_MPD_STATEFILE="${MPD_STATEFILE:-${MPD_DATADIR}/state}"
    check_writeable_path "${MPD_STATEFILE}" "state file" \
	"store mpd running status"
    CONF_MPD_STICKERFILE="${MPD_STICKERFILE:-${MPD_DATADIR}/sticker}"
    check_writeable_path "${MPD_STICKERFILE}" "sticker file" \
	"store dynamic user data"   
    
}


function conf_header() {
    ## construct the byline for the configuration file
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    formatted_date="$(date -Is)"

    printf "\n%s\n%s begin of %s\n%s created by \`%s' (version %s) on %s.\n%s see: %s\n%s" \
	"${MSG_CONF_LINESEP}" "${MSG_CONF_SEP}" "${MSG_CONF_TITLE}" \
	"${MSG_CONF_SEP}" "${APP_NAME_MPDCONFIGURE}" "${APP_VERSION}" "${formatted_date}" \
	"${MSG_CONF_SEP}" "${APP_URL}" "${MSG_CONF_LINESEP}"

}

function conf_footer() {
    ## construct the footer for the configuration file
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    printf "\n\n%s\n%s end of %s\n%s" \
	"${MSG_CONF_LINESEP}" "${MSG_CONF_SEP}" \
	"${MSG_CONF_TITLE}" "${MSG_CONF_LINESEP}"
}


function do_configure() {
    ## main function
    [[ ! -z "${DEBUG}" ]] && debug_function "${FUNCNAME}" "$*"

    ## get an array with available alsa hardware addresses
    fetch_alsa_hwaddresses
    [[ $? -eq 0 ]] || die_configure "error in fetch_alsa_hwaddresses."

    ## get and check paths
    get_mpd_musicdir
    [[ $? -eq 0 ]] || die_configure "error in get_mpd_musicdir."

    ## get and check paths
    get_mpd_homedir 
    [[ $? -eq 0 ]] || die_configure "error in get_mpd_homedir."

    ### perform automagic configuration
    perform_automagic
    [[ $? -eq 0 ]] || die_configure "error in perform_automagic."

    [[ ! -z ${DEBUG} ]] && \
	debug_configure "done with perform_automagic."
    
    ## store conf snippets in `CONF_CONTENTS`
    header="$(conf_header)"
    footer="$(conf_footer)"

    ## iterate each line in enabled files in `confs-enabled/*.conf`
    CONF_CONTENTS="${header}$(source_enabled_confs)${footer}"

    ## displays the contents of CONF_CONTENTS or write them to
    ## `CONF_MPD_CONFFILE` if set
    if [[ ! -z "${CONF_MPD_CONFFILE}" ]]; then
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "CONF_MPD_CONFFILE set to \`${CONF_MPD_CONFFILE}'."
	res="$(write_conffile "${CONF_MPD_CONFFILE}")"
	printf "%s\n" "${res}"
    else
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "CONF_MPD_CONFFILE left empty; printing to std_out."
	## display the results (print to std_out)
	printf "%s\n" "${CONF_CONTENTS}"
    fi

}

### program start

## check if we're re being sourced
SOURCED=""

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    SOURCED=True 
    ## store the current directory 
    SCRIPT_DIR=$(pwd)
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "script ${0} is being sourced; using SCRIPT_DIR \`${SCRIPT_DIR}'."
else
    ## store the directory in which the script resides
    SCRIPT_DIR=$(dirname $0)
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "script ${0} is being run; using SCRIPT_DIR \`${SCRIPT_DIR}'."
fi

if [[ ! -z ${DEBUG} ]]; then
    debug_configure "debugging turned on by user."
fi

## no problem if GNU find is not found; fail silently


## source own helper script if found
ALSA_CAPABILITIES_FILE="alsa-capabilities"
ALSA_CAPABILITIES_SCRIPT="${SCRIPT_DIR}/${ALSA_CAPABILITIES_FILE}"

if [[ -f "${ALSA_CAPABILITIES_SCRIPT}" ]]; then 
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "will source ALSA_CAPABILITIES_SCRIPT \`${ALSA_CAPABILITIES_SCRIPT}' ..."
    source "${ALSA_CAPABILITIES_SCRIPT}" 
    if [[ $? -eq 0 ]]; then
	[[ ! -z ${DEBUG} ]] && debug_configure "... done."
    else
	die_configure "error sourcing ALSA_CAPABILITIES_SCRIPT \`${ALSA_CAPABILITIES_SCRIPT}'."
    fi
else
    die_configure "required script \`${ALSA_CAPABILITIES_SCRIPT}' not found."
fi

## ugly temporary hack; see github issue #8
set +u
set +e

## list of enabled configuration snippet files
CONFS_ENABLED=${SCRIPT_DIR}/confs-enabled/*.conf
[[ ! -z ${DEBUG} ]] && debug_configure "CONFS_ENABLED: \`${CONFS_ENABLED}'."

## global indexed arrays that will be filled from `alsacapabilities.sh'
declare -a ALSA_AIF_HWADDRESSES=()
declare -a ALSA_AIF_DEVLABELS=()
declare -a ALSA_AIF_LABELS=()

## for storing (potential) problems 
declare -a PROBLEMS=()

## set to non empty to disable prompting 
DISABLE_PROMPTS="${DISABLE_PROMPTS:-}"
## set to non empty to overwrite an existing conf file without prompt
OVERWRITE_EXISTING_CONFFILE="${OVERWRITE_EXISTING_CONFFILE:-}"
TEMP_CONF_BACKUP="${TEMP_CONF_BACKUP:-}"

## source the config file if its present
PREFERENCES_FILE="${SCRIPT_DIR}/mpd-configure.conf"
if [[ -f "${PREFERENCES_FILE}" ]]; then
    source "${PREFERENCES_FILE}"
    [[ ! -z ${DEBUG} ]] && debug_configure "PREFERENCES_FILE sourced: \`${PREFERENCES_FILE}'"
else
    [[ ! -z ${DEBUG} ]] && debug_configure "PREFERENCES_FILE \`${PREFERENCES_FILE}' not found."
fi

CONF_MPD_CONFFILE="${CONF_MPD_CONFFILE:-}"

## for backwards compatibility
[[ ! -z "${CONF_ZEROCONF_ENABLED}" ]] || [[ ! -z "${ENABLE_LASTFM}" ]] && \
    die_configure "configuration settings \`CONF_ZEROCONF_ENABLED' and
    \`ENABLE_LASTFM' \nare no longer valid. please consult \`README'."

## for backwards compatibility
if [[ ! -z "${CONF_MPD_HOST}" ]] || [[ ! -z "${CONF_MPD_NETWORK_ADRESS}" ]]; then
    if [[ ! -z "${CONF_MPD_HOST}" ]] && [[ ! -z "${CONF_MPD_NETWORK_ADRESS}" ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    "Both CONF_MPD_HOST and CONF_MPD_NETWORK_ADRESS set by user, using the latter"
	G_NETWORK_BINDTOADDRESS="${CONF_MPD_NETWORK_ADRESS}"
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_NETWORK_ADRESS set by user to: \`${CONF_MPD_NETWORK_ADRESS}'."
    else
	
	if [[ ! -z "${CONF_MPD_HOST}" ]]; then
	    CONF_MPD_NETWORK_ADRESS="${CONF_MPD_HOST}"
	    G_NETWORK_BINDTOADDRESS="${CONF_MPD_NETWORK_ADRESS}"
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "CONF_MPD_NETWORK_ADRESS set by user through CONF_MPD_HOST to: \`${CONF_MPD_HOST}'."
	fi
	if [[ ! -z "${CONF_MPD_NETWORK_ADRESS}" ]]; then
	    G_NETWORK_BINDTOADDRESS="${CONF_MPD_NETWORK_ADRESS}"
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "CONF_MPD_NETWORK_ADRESS set by user to: \`${CONF_MPD_NETWORK_ADRESS}'."
	fi
    fi
else
    ## both not set; default
    CONF_MPD_NETWORK_ADRESS="${CONF_MPD_NETWORK_ADRESS_DEFAULT}"
    G_NETWORK_BINDTOADDRESS="${CONF_MPD_NETWORK_ADRESS}"
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "CONF_MPD_NETWORK_ADRESS set to default: \`${CONF_MPD_NETWORK_ADRESS}'."
fi

if [[ ! -z "${CONF_ZEROCONF_LABEL}" ]]; then 
    G_ZEROCONF_ZEROCONFNAME="${CONF_ZEROCONF_LABEL}"
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "G_ZEROCONF_ZEROCONFNAME set to CONF_ZEROCONF_LABEL: \`${CONF_ZEROCONF_LABEL}'"
fi
## global variable for holding the contents of the conf file
CONF_CONTENTS=""

## general messages and fixed strings
MSG_MPD_CONFFILE="mpd configuration file"
MSG_CONF_LINESEP="$(printf '#%.0s' {1..76})"
MSG_CONF_SEP="###"
MSG_CONF_TITLE="mpd configuration file"


## pass limits to the alsa-capabilities script
if [[ ! -z ${LIMIT_INTERFACE_TYPE} ]]; then
    case ${LIMIT_INTERFACE_TYPE} in
	"analog")
	    OPT_LIMIT_AO="True"
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Only process analog interfaces (OPT_LIMIT_AO): ${OPT_LIMIT_AO}"
	    ;;
	
	"digital")
	    OPT_LIMIT_DO="True" 
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Only process digital interfaces (OPT_LIMIT_DO): ${OPT_LIMIT_DO}"
	    ;;
	"usb"|"uac")
	    OPT_LIMIT_UO="True" 
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Only process usb interfaces (OPT_LIMIT_UO): ${OPT_LIMIT_UO}"
	    ;;
    esac
fi

if [[ ! -z ${LIMIT_INTERFACE_FILTER} ]]; then
    OPT_FILTER="${LIMIT_INTERFACE_FILTER}"
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "OPT_FILTER set to LIMIT_INTERFACE_FILTER: \`${LIMIT_INTERFACE_FILTER}'"
fi

## display (potential) problematic situations, like no right access to
## files and directories
if [[ ! -z "${DEBUG}" ]]; then
    if [[ ${#PROBLEMS[@]} -gt 0 ]]; then
	debug_configure "\nPotential problems found:\n${PROBLEMS[@]}"
    else
	debug_configure "No potential problems found."
    fi
fi

## if the script is sourced do nothing, otherwise run main flow
if [[ -z "${SOURCED}" ]]; then
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "start main function \`do_configure' ..."

    do_configure

    [[ ! -z ${DEBUG} ]] && \
	debug_configure "... main function \`do_configure' done."
else
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "you may run main function \`do_configure'."
    
fi

### done
