#!/usr/bin/env bash
##
## `mpd-configure' is a bash script that tries to ease the
## configuration of mpd for audiophile purposes.
##
##  Copyright (C) 2014 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## The script, helpers and documentation are published at 
## https://github.com/ronalde/mpd-configure
## 
## Also see `README'

LANG=C

function echo_stderr() {
    ## prevent messages from mixing with the actual output of the
    ## script (ie stdout)

    echo -e "$@" 1>&2; 
}

function die() {
    ## exit with error while displaying an error message $1

    echo_stderr "ERROR: $@"
    exit 1
}

function debug() {
    echo_stderr "DEBUG: ${1}"    
}


function write_error() {
    ## the conf file or dir ($1) is not writable and exists if ($2) is set. 
    ## echo the contents of the generated conf file to std_out and
    ## exit with error

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    path_notwritable="${1}"
    path_exists="${2}"

    if [[ -z ${path_exists} ]]; then
	msg="\n${MSG_TAB}can't write to ${path_notwritable}"
    else
	msg="\n${MSG_TAB}although ${path_notwritable} exists, it is not writable."
    fi
    msg="${msg}\n${MSG_MARGIN}the ${MSG_MPD_CONFFILE} can't be saved."
    [[ ! -z ${DEBUG} ]] && \
	debug "${msg}\n${MSG_TAB}Will display the generated contents instead."

    inform "${CONF_CONTENTS}"
    die "${msg}"
}


function really_write() {
    ## writes the contents of CONF_CONTENTS to MPD_CONFFILE

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    if [[ -z "${DRYRUN}" ]]; then
	## do the actual writing
	echo -e "${CONF_CONTENTS}" > "${MPD_CONFFILE}" && \
	    msg="${MSG_DONE}" || die "Could not write to \`${MPD_CONFFILE}': $?"
    else
	## dryrun enabled: display the contents of mpd_conffile
	msg="DRYRUN: Not writing to ${MPD_CONFFILE}: \
\n${CONF_CONTENTS} \
\n${MSG_DONE_DRYRUN}"
    fi

    ## display the result
    printf "${msg}"

    [[ ! -z "${DEBUG}" ]] && debug "result: \`${msg}'"

}

function write_conffile() {
    ## prepares to write to the mpd configuration file.

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    msg=""

    mpd_conf_dir="$(dirname ${MPD_CONFFILE})"

    if [[ ! -d "${mpd_conf_dir}" ]]; then
	[[ ! -z "${DEBUG}" ]] && debug "conf dir does not exist, try to create it"
	dirok="$(mkdir -p "${mpd_conf_dir}" 2>&1 >/dev/null)"
	[[ ! -z ${dirok} ]] && \
	    msg="Can't create directory \`${mpd_conf_dir}' which is necessary for storing \
\n${MSG_MARGIN}${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}'."
    else
	## conf dir exists, check if it writable
	[[ -w "${mpd_conf_dir}" ]] || \
	    msg="No write permission in directory \`${mpd_conf_dir}'."
    fi

    ## exit with error if this failed
    [[ ! -z "${msg}" ]] && die "\n${MSG_TAB}${msg}"

    [[ ! -z "${DEBUG}" ]] && debug "mpd_conf_dir ok: \`${mpd_conf_dir}'"

    if [[ -f "${MPD_CONFFILE}" ]]; then

	## conf file exists, check if its writable
	if [[ ! -w "${MPD_CONFFILE}" ]]; then
	    ## not writable, exit with error 
	    msg="\n${MSG_TAB}Existing ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}' is present, \
but is not writable."
	    die "${msg}"
	fi

	## is writable, prompt to overwrite
	msg="${MSG_TAB}Original ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}' exists."
	inform "${msg}"
	## only prompt when OVERWRITE_EXISTING_CONFFILE is not set
	[[ ! -z "${DEBUG}" ]] && \
	    debug "OVERWRITE_EXISTING_CONFFILE: \`${OVERWRITE_EXISTING_CONFFILE}'"
	if [[ -z ${OVERWRITE_EXISTING_CONFFILE} ]]; then
	    prompt="${MSG_MARGIN}>> Overwrite it?: "
	    overwrite="$(read -e -p "${prompt}" -i "Yes" overwrite && \
echo -e "${overwrite}")"
	    ## if prompt returns (downcased) `yes' then overwrite the file
	    if ! [[ "${overwrite,,}" = "yes" ]]; then
		## user choose no to overwrite; exit with message
		inform "Not overwriting existing ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}'."
		exit 0
	    fi
	fi
    fi

    ## do the actual writing
    fileok="$(really_write)"

}


function command_not_found() {
    ## give installation instructions when a command is not available
    ## and exit with error

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    command="$1"
    package="$2"
    instructions="$3"
    msg="Error: command \`${command}' not found. "

    [[ -z "${instructions}" ]] && \
	msg+="Users of Debian (or deratives, like Ubuntu) can install it with: \
\n sudo apt-get install ${package}" || \
	msg+="${instructions}"

    die "${msg}"

}

function fetch_alsa_hwaddresses() {
    ## use alsa-capabilities script to get alsa output interfaces; if
    ## one interface is found, use that, otherwise display all of them
    ## and ask the user which to use.
    ##
    ## stores the hardware address and label in global variables
    ## ALSA_AIF_HWADDRESS and ALSA_AIF_DEVLABEL.

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    ## prompt when multiple alsa interfaces are found
    msg_multiple_alsahw="${MSG_TAB}Multiple interfaces found."

    ## when more than one matching output device is found and
    ## USER_PROMPTS is not set, prompt the user to select one,
    ## defaults to the first device found.

    ## put the result of alsa-capabilities in an array
    return_alsa_interface

    [[ ! -z ${DEBUG} ]] && \
	debug "number of returned alsa interfaces: ${#ALSA_AIF_HWADDRESSES[@]}"

    ## set first interface found as default
    selectedkey=0
    default_aif_hwaddress="${ALSA_AIF_HWADDRESSES[${selectedkey}]}"

    if [[ ${#ALSA_AIF_HWADDRESSES[@]} -gt 1 ]]; then
	if [[ -z "${USER_PROMPTS}" ]]; then
	    ## display instructions for multiple interfaces and prompt
	    #echo_stderr "${msg_multiple_alsahw}"
	    #prompt="${MSG_MARGIN}>> Interface to use: "
	    msg_prompt=">> Specify the interface to use and press [ENTER] to confirm: "
	    prompt="$(printf '%s\n%s' "${msg_multiple_alsahw}" \
"${MSG_MARGIN}${msg_prompt}")"
	    ## prompt the user to select a interface
	    alsa_aif_hwaddress="$(read -e -p "${prompt}" \
-i "${default_aif_hwaddress}" alsa_aif_hwaddress && \
echo -e "${alsa_aif_hwaddress}")"

	    for key in "${!ALSA_AIF_HWADDRESSES[@]}"; do
		## set the user selected key and exit loop
		if [[ "${ALSA_AIF_HWADDRESSES[$key]}" = "${alsa_aif_hwaddress}" ]]; then
		   let selectedkey=${key}
		   break
		fi
	    done
	fi
    fi

    ## store the hardware address and label for usage in audio_conf
    CONF_ALSA_AIF_HWADDRESS="${ALSA_AIF_HWADDRESSES[${selectedkey}]}"
    CONF_ALSA_AIF_DEVLABEL="${ALSA_AIF_DEVLABELS[${selectedkey}]} - \
${ALSA_AIF_LABELS[${selectedkey}]}"
}


function check_readable_path() {
    ## checks if path ($1), needed for ($2) is readable, or adds
    ## problem description ($2) to problems array

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$*'"
    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n${MSG_TAB}Can't access or read ${purpose} \`${path}',\
\n${MSG_MARGIN}you won't be able to ${problem}.\n"
    [[ -d "${path}" || -f "${path}" ]] || PROBLEMS+=("${msg}") 
}


function check_writeable_path() {
    ## checks if path ($1), needed for ($2) is writeable, or adds
    ## problem description ($2) to problems array

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n${MSG_TAB}Can't write to ${purpose} \`${path}',\
\n${MSG_MARGIN}you won't be able to ${problem}.\n"

    [[ -w "${path}" ]] || PROBLEMS+=("${msg}") 
}

function parse_configuration_line() {

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    line="$@"

    ## construct the regular expression for configuration items
    local brm='([[:alpha:][:alnum:]_]*)[[:space:]]*\"\$\{(.*)\}\"$'
    ## match the regexp
    if [[ "${line}" =~ ${brm} ]] ; then
	## line is mpd configuration: `config_value "${...}"'
	
	## given a line of `config_value "${...}"'
	## the name of the variable with or without a default value: `...'
	var_part="${BASH_REMATCH[2]}"
	var_template="${var_part}"
	var_search="${var_template}"
	if [[ "${var_part}" =~ ^(.*):-(.*)$ ]]; then
	    ## the line contains a variable with default value:
	    ##  `config_value "${VARNAME:-default_value}"'

	    ## store the variable name: `VARNAME'
	    var_template="${BASH_REMATCH[1]}"
	    var_value="${BASH_REMATCH[2]}"
	    ## the variable name including its default value `VARNAME:-default_value'
	    var_search="${BASH_REMATCH[1]}:-${BASH_REMATCH[2]}"
	fi
	## assign the name of the variable (`VARNAME') to $expanded_name
	exp_name=var_template
	## assign the value of the variable (`$VARNAME') to $expanded_value
	local exp_value="${!exp_name}"
	
	## return the line with its real/expanded value
	if [[ ! -z "${!exp_value}" ]]; then
	    printf "%s" "${line//\$\{${var_search}\}/${!exp_value}}"
	else
	    [[ -z ${INCLUDE_COMMENTS} ]] && \
		printf "" || \
		printf "# %s (value not set)" "${line//\$\{${var_search}\}/${!exp_value}}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "not writing empty configuration setting \`${var_template}'."
	fi
    else
	## a normal line; return it
	printf "%s" "${line}"
    fi
    
}

function source_enabled_confs() {
    ## source conf snippets in ./confs-enabled/*.conf while
    ## substituting the variables in those conf files with the ones
    ## generated in this script.

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    ## temporary file needed to source enabled configuration snippets files
    tempconfs="$(mktemp)"

    ## fill the file with all configuration lines from `confs-enabled/*.conf`
    sed 's/^\([[:alnum:][:space:]_]*\)[[:space:]]*"\${\(.*\):-\(.*\)}"$/export \2="\${\2:-\3}"/' \
	${SCRIPT_DIR}/confs-enabled/*.conf | grep -E ^export > "${tempconfs}"

    ## source it (needed for variable expansion)
    source "${tempconfs}" || die "could not source \`${tempconfs}'"

    ## remove it when DEBUG is not set
    [[ ! -z "${DEBUG}" ]] && \
	debug "sourced configuration values stored in \`${tempconfs}'.\n" || \
	rm "${tempconfs}"

    ## iterate each file
    for conf_file in ${CONFS_ENABLED}; do

	## check if the symlink points to a valid file
	isvalid="$(readlink -e "${conf_file}")"

	## process the next one if the symlink is broken 
	if [[ -z "${isvalid}" ]]; then
	    [[ ! -z "${DEBUG}" ]] && debug "not a valid symlink \`${conf_file}'"
	    continue
	fi

	## the file exists, parse it
	printf "\n## start processing \`%s'\n" "${conf_file##*/}"

	## iterate each line
	while IFS='' read -r line ; do

	    ## skip commented lines
	    ## create trimmed version of line
	    if [[ -z ${INCLUDE_COMMENTS} ]]; then
		trimmed=$([[ "${line}" =~ [[:space:]]*([^[:space:]]|[^[:space:]].*[^[:space:]])[[:space:]]* ]]; echo -n "${BASH_REMATCH[1]}")

		if [[ "${trimmed#\#*}" = "${trimmed}" ]]; then
		    if [[ ! -z "${trimmed}" ]]; then
			## parse the line
			line="$(parse_configuration_line "${line}")"
			
			local interpreted_line="${!line}"
			## original code
			[[ ! -z "${line}" ]] && \
			    printf "%s\n" "${line}"
		    fi
		fi
	    else
		line="$(parse_configuration_line "${line}")"
		echo -e "${line}"
	    fi
	done <${conf_file}
	echo -e "## done processing"
    done
}

function perform_automagic() {
    ### automagic configuration stuff

    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$@'"

    ## client limits
    ## if the directory specified in `CONF_MPD_MUSICDIR` is
    ## accessible, calculate the number of audio files and double that
    ## for `max_playlist_length` parameter.
    
    default_length=16384
    nr_musicfiles=0

    if [[ -z ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} ]]; then
	## setting not configured
	if [[ -d "${CONF_MPD_MUSICDIR}" ]]; then
	    ## music dir exists; calculate number of files
	    if [[ ! -z ${CMD_FIND} ]]; then
		let nr_musicfiles=$(${CMD_FIND} "${CONF_MPD_MUSICDIR}" -type f | wc -l)
	    else
		## find not available; use bash wildcards
		[[ shopt -q globstar ]] && globstar_initial_on=True
		## turn it on
		shopt -s globstar
		musicfiles="${CONF_MPD_MUSICDIR}/**"
		let nr_musicfiles="$(printf "file: \`%s'\n" ${musicfiles} | wc -l)"
		## turn it of if needed
		[[ ! -z ${globstar_initial_on} ]] && shopt -u globstar

	    fi

	    let double_nr_musicfiles=( ${nr_musicfiles} * 2 )
	    [[ ${double_nr_musicfiles} -gt ${default_length} ]] && \
		G_CLIENTLIMITS_MAXPLAYLISTLENGTH=${double_nr_musicfiles} || \
		G_CLIENTLIMITS_MAXPLAYLISTLENGTH=${default_length}
	else
	    ## music dir not available; use default
	    G_CLIENTLIMITS_MAXPLAYLISTLENGTH=${default_length}
	fi
    fi
    
    ## if empty set `G_CLIENTLIMITS_MAXCOMMANDLISTSIZE` to 1/8 of
    ## `G_CLIENTLIMITS_MAXPLAYLISTLENGTH`
    [[ -z ${G_CLIENTLIMITS_MAXCOMMANDLISTSIZE} && \
	! -z ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} ]] && \
	let G_CLIENTLIMITS_MAXCOMMANDLISTSIZE=( ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} / 8 )
    
    ## if empty, set `MAXOUTPUTBUFFERSIZE` to 1/2 of
    ## `G_CLIENTLIMITS_MAXPLAYLISTLENGTH`
    [[ -z ${G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE} && \
	! -z ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} ]] && \
	let G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE=( ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} / 2 )
    
    if [[ ! -z "${DEBUG}" ]]; then
	debug "G_CLIENTLIMITS_MAXPLAYLISTLENGTH: \`${G_CLIENTLIMITS_MAXPLAYLISTLENGTH}'"
	debug "G_CLIENTLIMITS_MAXCOMMANDLISTSIZE: \`${G_CLIENTLIMITS_MAXCOMMANDLISTSIZE}'"
	debug "G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE: \`${G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE}'"
    fi
    
    ## get network name for zeroconf
    if [[ -z "${G_ZEROCONF_ZEROCONFNAME}" ]]; then
	## `G_ZEROCONF_ZEROCONFNAME` is not set; set default zeroconf label 
	
	hostname_string=""
	if [[ ! "${CONF_MPD_HOST}" =~ "127.0.0" || ! "${CONF_MPD_HOST}" = "0.0.0.0" ]]; then
	    ## real ip address; try to get fqdn name, fallback to 'short' hostname
	    hostname="$(hostname --fqdn)"
	    [[ -z "${hostname}" ]] && \
		hostname="$(hostname)"
	fi
	
	## set string to use if hostname contains something
	[[ ! -z ${hostname} ]] && \
	    hostname_string="on ${hostname} "
	
	G_ZEROCONF_ZEROCONFNAME="${ZEROCONF_NAME:-MPD \
${hostname_string}through ${CONF_ALSA_AIF_DEVLABEL}}"
	
    fi

}

function get_and_check_paths() {
    ### get and check paths

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    ### music dir
    ## check if user set the music dir configuration parameters
    if [[ -z ${CONF_MPD_MUSICDIR} && -z ${G_PATHS_MUSICDIRECTORY} ]]; then
	## try getting the `MUSIC' directory from XDG and use that,
	## otherwise user current dir
	if [[ ! -z ${CMD_XDGUSERDIR} ]]; then 
	    xdg_music_dir="$(${CMD_XDGUSERDIR} MUSIC)"
	    [[ "$?" = "0" ]] && \
		G_PATHS_MUSICDIRECTORY="${xdg_music_dir}"
	fi
    fi
    
    ## use current dir if still empty
    [[ -z ${G_PATHS_MUSICDIRECTORY} ]] && G_PATHS_MUSICDIRECTORY="$(pwd)"
    
    check_readable_path "${G_PATHS_MUSICDIRECTORY}" "music directory" "listen to music"
    
    ## working directory for mpd
    
    ## use user xdg config dir or current path
    XDG_CONFIG_DIR="${HOME}/.config"
    [[ -d ${XDG_CONFIG_DIR} ]] || \
	XDG_CONFIG_DIR=$(pwd)
    
    ## set default path
    XDG_CONFIG_MPDDIR=${XDG_CONFIG_DIR}/mpd
    
    ## if `CONF_MPD_HOMEDIR` not set by user, otherwise use `XDG_CONFIG_MPDDIR`
    [[ -z ${CONF_MPD_HOMEDIR} ]] && \
	CONF_MPD_HOMEDIR=${XDG_CONFIG_MPDDIR}
    
    ## check if it is accessible
    check_readable_path "${CONF_MPD_HOMEDIR}" "mpd home directory" \
	"use ${MSG_MPD_CONFFILE}"
    check_writeable_path "${CONF_MPD_HOMEDIR}" "mpd home directory" \
	"store ${MSG_MPD_CONFFILE}"
    
    ## where to store data
    MPD_DATADIR="${MPD_DATADIR:-${CONF_MPD_HOMEDIR}}"
    CONF_MPD_PLAYLISTDIR="${MPD_PLAYLISTDIR:-${MPD_DATADIR}/playlists}"
    check_readable_path "${MPD_PLAYLISTDIR}" "playlist directory" "use playlists"
    check_writeable_path "${MPD_PLAYLISTDIR}" "playlist directory" \
	"change or create playlists"
    CONF_MPD_DBFILE="${MPD_DBFILE:-${MPD_DATADIR}/tag_cache}"
    check_readable_path "${MPD_DBFILE}" "database file" "use mpd"
    check_writeable_path "${MPD_DBFILE}" "database file" "store changes in mpd"
    CONF_MPD_LOGFILE="${MPD_LOGFILE:-${MPD_DATADIR}/mpd.log}"
    check_writeable_path "${MPD_LOGFILE}" "log file" "start or use mpd"
    CONF_MPD_PIDFILE="${MPD_PIDFILE:-${MPD_DATADIR}/pid}"
    check_writeable_path "${MPD_PIDFILE}" "PID file" \
	"start, stop or restart mpd using service daemon"
    CONF_MPD_STATEFILE="${MPD_STATEFILE:-${MPD_DATADIR}/state}"
    
}


function conf_header() {
    ## construct the byline for the configuration file

    formatted_date="$(date -Is)"
    app_url="https://github.com/ronalde/${APP_NAME}/"

    printf "\n%s\n%s begin of %s\n%s created by \`%s' on %s.\n%s see: %s\n%s" \
	"${MSG_CONF_LINESEP}" "${MSG_CONF_SEP}" "${MSG_CONF_TITLE}" \
	"${MSG_CONF_SEP}" "${APP_NAME}" "${formatted_date}" \
	"${MSG_CONF_SEP}" "${app_url}" "${MSG_CONF_LINESEP}\n"

}

function conf_footer() {
    printf "\n\n%s\n%s end of %s\n%s" \
	"${MSG_CONF_LINESEP}" "${MSG_CONF_SEP}" \
	"${MSG_CONF_TITLE}" "${MSG_CONF_LINESEP}\n"
}

### program start

APP_NAME="mpd-configure"

## store the current directory 
SCRIPT_DIR=$(dirname $0)

## check if needed programs are available
## no problem if xdg-userdir is not found; fail silently
CMD_XDGUSERDIR=$(which xdg-user-dir)
## no problem if GNU find is not found; fail silently
CMD_FIND=$(which find)

ALSA_CAPABILITIES_FILE="alsa-capabilities"
ALSA_CAPABILITIES_SCRIPT="${SCRIPT_DIR}/${ALSA_CAPABILITIES_FILE}"

[[ -f "${ALSA_CAPABILITIES_SCRIPT}" ]] && \
    . "${ALSA_CAPABILITIES_SCRIPT}" || \
    die "required script \`${ALSA_CAPABILITIES_SCRIPT}' not found"

## list of enabled configuration snippet files
CONFS_ENABLED=${SCRIPT_DIR}/confs-enabled/*.conf

## global indexed arrays that will be filled from `alsacapabilities.sh'
declare -a ALSA_AIF_HWADDRESSES=()
declare -a ALSA_AIF_DEVLABELS=()
declare -a ALSA_AIF_LABELS=()

## for storing (potential) problems 
declare -a PROBLEMS=()

## source the config file if its present
PREFERENCES_FILE="${SCRIPT_DIR}/mpd-configure.conf"
[[ -f "${PREFERENCES_FILE}" ]] && \
    source "${PREFERENCES_FILE}"

## if not set, default to 0.0.0.0
CONF_MPD_HOST="${CONF_MPD_HOST:-0.0.0.0}"

## for backwards compatibility
[[ ! -z "${CONF_ZEROCONF_ENABLED}" ]] || [[ ! -z "${ENABLE_LASTFM}" ]] && \
    die "configuration settings \`CONF_ZEROCONF_ENABLED' and
    \`ENABLE_LASTFM' \nare no longer valid. please consult \`README'."

## for backwards compatibility
[[ ! -z "${CONF_MPD_HOST}" ]] && G_NETWORK_BINDTOADDRESS="${CONF_MPD_HOST}"
[[ ! -z "${CONF_ZEROCONF_LABEL}" ]] && G_ZEROCONF_ZEROCONFNAME="${CONF_ZEROCONF_LABEL}"
## global variable for holding the contents of the conf file
CONF_CONTENTS=""

## general messages and fixed strings
MSG_MPD_CONFFILE="mpd configuration file"
MSG_DONE="\n\n${MSG_MPD_CONFFILE} saved in \`${MPD_CONFFILE}'.\n"
MSG_DONE_DRYRUN="\ndryrun mpd configuration done (not saved).\n"
MSG_TAB=" * "
MSG_MARGIN="${MSG_TAB//\*/ }"
MSG_CONF_LINESEP="$(printf '#%.0s' {1..76})"
MSG_CONF_SEP="###"
MSG_CONF_TITLE="mpd configuration file"


## pass limits to the alsa-capabilities script
if [[ ! -z ${LIMIT_INTERFACE_TYPE} ]]; then
    case ${LIMIT_INTERFACE_TYPE} in
	"analog")
	    OPT_LIMIT_AO="True" ;;
	"digital")
	    OPT_LIMIT_DO="True" ;;
	"usb"|"uac")
	    OPT_LIMIT_UO="True" ;;
    esac
fi

[[ ! -z ${LIMIT_INTERFACE_FILTER} ]] && OPT_FILTER="${LIMIT_INTERFACE_FILTER}"

## display (potential) problematic situations, like no right access to
## files and directories

[[ ! -z "${DEBUG}" ]] && \
    debug "\nPotential problems for the current configuration:\n${PROBLEMS[@]}\n"

## get an array with available alsa hardware addresses
fetch_alsa_hwaddresses

## get and check paths
get_and_check_paths

### perform automagic configuration
perform_automagic

## store conf snippets in `CONF_CONTENTS`
header="$(conf_header)"
footer="$(conf_footer)"

## iterate each line in enabled files in `confs-enabled/*.conf`
CONF_CONTENTS="${header}$(source_enabled_confs)${footer}"

## displays the contents of CONF_CONTENTS or write them to
## `MPD_CONFFILE` if set
[[ -z "${MPD_CONFFILE}" ]] && \
    printf "%s\n" "${CONF_CONTENTS}" ||  \
    write_conffile

### done
