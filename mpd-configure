#!/usr/bin/env bash
##
## `mpd-configure' is a bash script that tries to ease the
## configuration of mpd for audiophile purposes.
##
##  Copyright (C) 2014 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## The script, helpers and documentation are published at 
## https://github.com/ronalde/mpd-configure
## 
## Also see `README'

LANG=C

function echo_stderr() {
    ## prevent messages from mixing with the actual output of the
    ## script (ie stdout)

    echo -e "$@" 1>&2; 
}

function die() {
    ## exit with error while displaying an error message $1

    echo_stderr "ERROR: $@"
    exit 1
}

function debug() {
    echo_stderr "DEBUG: ${1}"    
}


function write_error() {
    ## the conf file or dir ($1) is not writable and exists if ($2) is set. 
    ## echo the contents of the generated conf file to std_out and
    ## exit with error

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    path_notwritable="${1}"
    path_exists="${2}"

    if [[ -z ${path_exists} ]]; then
	msg="\n${MSG_TAB}can't write to ${path_notwritable}"
    else
	msg="\n${MSG_TAB}although ${path_notwritable} exists, it is not writable."
    fi
    msg="${msg}\n${MSG_MARGIN}the ${MSG_MPD_CONFFILE} can't be saved."
    [[ ! -z ${DEBUG} ]] && \
	debug "${msg}\n${MSG_TAB}Will display the generated contents instead."

    inform "${CONF_CONTENTS}"
    die "${msg}"
}


function really_write() {

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    if [[ -z "${DRYRUN}" ]]; then
	## do the actual writing
	echo -e "${CONF_CONTENTS}" > "${MPD_CONFFILE}" && \
	    msg="${MSG_DONE}"
    else
	## dryrun enabled: display the contents of mpd_conffile
	msg="DRYRUN: Not writing to ${MPD_CONFFILE}: \
\n${CONF_CONTENTS} \
\n${MSG_DONE_DRYRUN}"
	
    fi

    printf "${msg}"

}

function write_conffile() {
    ## prepares to write to the mpd configuration file.

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    msg=""

    mpd_conf_dir="$(dirname ${MPD_CONFFILE})"

    if [[ ! -d "${mpd_conf_dir}" ]]; then
	## conf dir does not exist, try to create it
	dirok="$(mkdir -p "${mpd_conf_dir}" 2>&1 >/dev/null)"
	[[ ! -z ${dirok} ]] && \
	    msg="Can't create directory \`${mpd_conf_dir}' which is necessary for storing \
\n${MSG_MARGIN}${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}'."
    else
	## conf dir exists, check if it writable
	[[ -w "${mpd_conf_dir}" ]] || \
	    msg="No write permission in directory \`${mpd_conf_dir}'."
    fi

    ## exit with error if this failed
    [[ ! -z "${msg}" ]] && die "\n${MSG_TAB}${msg}"

    if [[ -f "${MPD_CONFFILE}" ]]; then
	## conf file exists, check if its writable
	if [[ ! -w "${MPD_CONFFILE}" ]]; then
	    ## not writable, exit with error 
	    msg="\n${MSG_TAB}Existing ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}' is present, \
but is not writable."
	    die "${msg}"
	else
	    ## is writable 
   	    msg="${MSG_TAB}Original ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}' exists."
	    inform "${msg}"
	    prompt="${MSG_MARGIN}>> Overwrite it?: "
	    overwrite="$(read -e -p "${prompt}" \
-i "Yes" overwrite && \
echo -e "${overwrite}")"
	    ## if prompt returns (downcased) `yes' then overwrite the file
	    if [[ "${overwrite,,}" = "yes" ]]; then
		## user choose to overwrite, try that
		fileok="$(really_write)"
	    else
		## user choose no to overwrite; exit with message
		inform "Not overwriting existing ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}'."
		exit 0
	    fi
	fi
    fi

}

function store_conf() {
    ## appends the contents of the argument $1 to the
    ## variable holding the configuration contents

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    conf_snippet="$1"

    ## append the snippet to the global conf variable
    CONF_CONTENTS="${CONF_CONTENTS}${conf_snippet}"
}


function command_not_found() {
    ## give installation instructions when a command is not available
    ## and exit with error

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    command="$1"
    package="$2"
    instructions="$3"
    msg="Error: command \`${command}' not found. "

    [[ -z "${instructions}" ]] && \
	msg+="Users of Debian (or deratives, like Ubuntu) can install it with: \
\n sudo apt-get install ${package}" || \
	msg+="${instructions}"

    die "${msg}"

}

function fetch_alsa_hwaddresses() {
    ## use alsa-capabilities script to get alsa output interfaces; if
    ## one interface is found, use that, otherwise display all of them
    ## and ask the user which to use.
    ##
    ## stores the hardware address and label in global variables
    ## ALSA_AIF_HWADDRESS and ALSA_AIF_DEVLABEL.

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    ## prompt when multiple alsa interfaces are found
    msg_multiple_alsahw="${MSG_TAB}Multiple interfaces found."

    ## when more than one matching output device is found and
    ## USER_PROMPTS is not set, prompt the user to select one,
    ## defaults to the first device found.

    ## put the result of alsa-capabilities in an array
    return_alsa_interface

    [[ ! -z ${DEBUG} ]] && \
	debug "number of returned alsa interfaces: ${#ALSA_AIF_HWADDRESSES[@]}"

    ## set first interface found as default
    selectedkey=0
    default_aif_hwaddress="${ALSA_AIF_HWADDRESSES[${selectedkey}]}"

    if [[ ${#ALSA_AIF_HWADDRESSES[@]} -gt 1 ]]; then
	if [ -z "${USER_PROMPTS}" ]; then
	    ## display instructions for multiple interfaces and prompt
	    #echo_stderr "${msg_multiple_alsahw}"
	    #prompt="${MSG_MARGIN}>> Interface to use: "
	    msg_prompt=">> Specify the interface to use and press [ENTER] to confirm: "
	    prompt="$(printf '%s\n%s' "${msg_multiple_alsahw}" \
"${MSG_MARGIN}${msg_prompt}")"
	    ## prompt the user to select a interface
	    alsa_aif_hwaddress="$(read -e -p "${prompt}" \
-i "${default_aif_hwaddress}" alsa_aif_hwaddress && \
echo -e "${alsa_aif_hwaddress}")"

	    for key in "${!ALSA_AIF_HWADDRESSES[@]}"; do
		## set the user selected key and exit loop
		if [[ "${ALSA_AIF_HWADDRESSES[$key]}" = "${alsa_aif_hwaddress}" ]]; then
		   let selectedkey=${key}
		   break
		fi
	    done
	fi
    fi

    ## store the hardware address and label for usage in audio_conf
    ALSA_AIF_HWADDRESS="${ALSA_AIF_HWADDRESSES[${selectedkey}]}"
    ALSA_AIF_DEVLABEL="${ALSA_AIF_DEVLABELS[${selectedkey}]} - \
${ALSA_AIF_LABELS[${selectedkey}]}"
}

function audio_conf() {
    ## return the configured audio section for mpd.conf
    ## the ALSA_AIF* variables are filled in fetch_alsa_hwaddresses

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    section="audio"
    IFS='' read -r -d '' conf <<EOF
## start ${section} section
audio_output {
 type                "alsa"
 name                "${ALSA_AIF_DEVLABEL}"
 device              "${ALSA_AIF_HWADDRESS}"
 auto_resample       "no"
 auto_format         "no"
 }
## end ${section} section

EOF

    store_conf "${conf}"

}


function network_conf() {
    ## configure the network section

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    section="network"

    IFS='' read -r -d '' conf <<EOF
## start ${section} section
bind_to_address     "${MPD_HOST}"
## end ${section} section

EOF

    store_conf "${conf}"
}

function paths_conf() {
    ## construct paths and file entries for mpd.conf

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    section="paths"
    IFS='' read -r -d '' conf <<EOF
## start ${section} section
music_directory     "${MPD_MUSICDIR}"
playlist_directory  "${MPD_PLAYLISTDIR}"
db_file             "${MPD_DBFILE}"
log_file            "${MPD_LOGFILE}"
pid_file            "${MPD_PIDFILE}"
state_file          "${MPD_STATEFILE}"
## end ${section} section

EOF

    store_conf "${conf}"

}

function misc_conf() {
    ## construct other entries for mpd.conf 

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    section="misc"
    IFS='' read -r -d '' conf <<EOF
## start ${section} section
filesystem_charset  "UTF-8"
id3v1_encoding      "UTF-8"
auto_update         "yes"
replaygain          "off"
mixer_type          "none"
max_playlist_length "16777216"

## end ${section} section

EOF

    store_conf "${conf}"

}

function zeroconf_conf() {
    ## constructs zeroconf entries for mpd.conf

    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$@'"

    if [ -n "${ENABLE_ZEROCONF}" ]; then
	zeroconf_label="${ZEROCONF_NAME:-MPD through ${ALSA_AIF_DEVLABEL}}"
	section="zeroconf"
	IFS='' read -r -d '' conf <<EOF
## start ${section} section
zeroconf_enabled    "yes"
zeroconf_name       "${zeroconf_label}"
## end section ${section}

EOF
	store_conf "${conf}"
    fi
}

function lastfm_conf() {
    # construct lastfm section for mpd.conf

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    section="lastfm"
    if [ -n "${ENABLE_LASTFM}" ]; then
	if [ -n "${LASTFM_USERNAME}" ] && [ -n "${LASTFM_PASSWORD}" ]; then
	    IFS='' read -r -d '' conf <<EOF
## start ${section} section
playlist_plugin {
    name                "lastfm"
    user                "${LASTFM_USERNAME}"
    password            "${LASTFM_PASSWORD}"
    }
## end ${section} section
EOF
	    store_conf "${conf}"
	else
	    die "\`ENABLE_LASTFM' set but either \`LASTFM_USERNAME' \
 or \`LASTFM_PASSWORD' empty."
	fi
    fi
}

function check_readable() {
    ## checks if path ($1), needed for ($2) is readable, or adds
    ## problem description ($2) to problems array

    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n${MSG_TAB}Can't access or read ${purpose} \`${path}',\
\n${MSG_MARGIN}you won't be able to ${problem}.\n"
    [[ -d "${path}" || -f "${path}" ]] || PROBLEMS+=("${msg}") 
}


function check_writeable() {
    ## checks if path ($1), needed for ($2) is writeable, or adds
    ## problem description ($2) to problems array

    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n${MSG_TAB}Can't write to ${purpose} \`${path}',\
\n${MSG_MARGIN}you won't be able to ${problem}.\n"

    [[ -w "${path}" ]] || PROBLEMS+=("${msg}") 
}

### program start

APP_NAME="mpd-configure"

## store the current directory 
SCRIPT_DIR=$(dirname $0)

ALSA_CAPABILITIES_FILE="alsa-capabilities"
ALSA_CAPABILITIES_SCRIPT="${SCRIPT_DIR}/${ALSA_CAPABILITIES_FILE}"

[[ -f "${ALSA_CAPABILITIES_SCRIPT}" ]] && \
    . "${ALSA_CAPABILITIES_SCRIPT}" || \
    die "required script \`${ALSA_CAPABILITIES_SCRIPT}' not found"

## global indexed arrays that will be filled from `alsacapabilities.sh'
declare -a ALSA_AIF_HWADDRESSES=()
declare -a ALSA_AIF_DEVLABELS=()
declare -a ALSA_AIF_LABELS=()

## for storing (potential) problems 
declare -a PROBLEMS=()

## users may change the global variables that this script uses in the
## file `mpd-configure.conf' or specify them on the command line when
## starting this script, eg: 
##  MPD_HOST="myhostname" ./mpd-configure

## source the config file if its present
PREFERENCES_FILE="${SCRIPT_DIR}/mpd-configure.conf"
[[ -f "${PREFERENCES_FILE}" ]] && \
    source "${PREFERENCES_FILE}"

## global variable for holding the contents of the conf file
CONF_CONTENTS=""

## general messages and fixed strings
MSG_MPD_CONFFILE="mpd configuration file"
MSG_DONE="\n\n${MSG_MPD_CONFFILE} saved in \`${MPD_CONFFILE}'.\n"
MSG_DONE_DRYRUN="\ndryrun mpd configuration done (not saved).\n"
MSG_TAB=" * "
MSG_MARGIN="${MSG_TAB//\*/ }"

## check if needed programs are available
CMD_APLAY=$(which aplay || command_not_found "aplay" "alsa-utils")

## if not set, default to 0.0.0.0
MPD_HOST="${MPD_HOST:-0.0.0.0}"

if [[ -z ${MPD_MUSICDIR} ]]; then
    ## get `music' directory from xdg
    XDG_USER_USERDIRS=${HOME}/.config/user-dirs.dirs
    ## source the user settings if present to fill XDG_MUSIC_DIR
    [[ -f ${XDG_USER_USERDIRS} ]] && source ${XDG_USER_USERDIRS}
    ## if empty revert to HOME
    [[ -z ${XDG_MUSIC_DIR} ]] && XDG_MUSIC_DIR=${HOME}
fi

## defaults to $XDG_MUSIC_DIR
MPD_MUSICDIR="${MPD_MUSICDIR:-${XDG_MUSIC_DIR}}"
check_readable "${MPD_MUSICDIR}" "music directory" "listen to music"

## working directory for mpd
MPD_USERHOMEDIR="${MPD_USERHOMEDIR:-${HOME}/.mpd}"
check_readable "${MPD_USERHOMEDIR}" "mpd home directory" "use ${MSG_MPD_CONFFILE}"
check_writeable "${MPD_USERHOMEDIR}" "mpd home directory" "store ${MSG_MPD_CONFFILE}"
## where to store data
MPD_DATADIR="${MPD_DATADIR:-${MPD_USERHOMEDIR}}"
MPD_PLAYLISTDIR="${MPD_PLAYLISTDIR:-${MPD_DATADIR}/playlists}"
check_readable "${MPD_PLAYLISTDIR}" "playlist directory" "use playlists"
check_writeable "${MPD_PLAYLISTDIR}" "playlist directory" "change or create playlists"
MPD_DBFILE="${MPD_DBFILE:-${MPD_DATADIR}/tag_cache}"
check_readable "${MPD_DBFILE}" "database file" "use mpd"
check_writeable "${MPD_DBFILE}" "database file" "store changes in mpd"
MPD_LOGFILE="${MPD_LOGFILE:-${MPD_DATADIR}/mpd.log}"
check_writeable "${MPD_LOGFILE}" "log file" "start or use mpd"
MPD_PIDFILE="${MPD_PIDFILE:-${MPD_DATADIR}/pid}"
check_writeable "${MPD_PIDFILE}" "PID file" "start, stop or restart mpd using service daemon"
MPD_STATEFILE="${MPD_STATEFILE:-${MPD_DATADIR}/state}"


## pass limits to the alsa-capabilities script
if [[ ! -z ${LIMIT_INTERFACE_TYPE} ]]; then
    case ${LIMIT_INTERFACE_TYPE} in
	"analog")
	    OPT_LIMIT_AO="True" ;;
	"digital")
	    OPT_LIMIT_DO="True" ;;
	"usb"|"uac")
	    OPT_LIMIT_UO="True" ;;
    esac
fi

[[ ! -z ${LIMIT_INTERFACE_FILTER} ]] && OPT_FILTER="${LIMIT_INTERFACE_FILTER}"

debug "\nPotential problems for the current configuration:\n${PROBLEMS[@]}\n"
### start constructing the conf files' contents
## construct the byline
formatted_date="$(date -Is)"
app_url="https://github.com/ronalde/${APP_NAME}/"

msg_conf_linesep="$(printf '#%.0s' {1..76})"
msg_conf_sep="###"
msg_conf_title="mpd configuration file"

msg_conf_begin="\n${msg_conf_linesep}\n${msg_conf_sep} begin ${msg_conf_title}\n"
msg_conf_end="${msg_conf_sep} end ${msg_conf_title}\n${msg_conf_linesep}\n"

store_conf "${msg_conf_begin}"
app_created_by="${msg_conf_sep} created by \`${APP_NAME}' on ${formatted_date}. \
\n${msg_conf_sep} see: ${app_url}\n\n"
store_conf "${app_created_by}"

## get an array with available alsa hardware addresses
fetch_alsa_hwaddresses

## store conf snippets in CONF_CONTENTS
network_conf
paths_conf
audio_conf
misc_conf
lastfm_conf
zeroconf_conf

## print the footer 
store_conf "${msg_conf_end}"

## displays the contents of CONF_CONTENTS or write them to MPD_CONFFILE if set
[[ -z "${MPD_CONFFILE}" ]] && \
    echo -e "${CONF_CONTENTS}" ||  \
    write_conffile

### done
