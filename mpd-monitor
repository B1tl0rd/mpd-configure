#!/usr/bin/env bash

## This script for linux with bash 4.x displays the properties of a
## digital audio file as stored, transferred by mpd and decoded by alsa.
##
##  Copyright (C) 2015 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## Source:    https://github.com/ronalde/mpd-configure
## See also:  http://lacocina.nl/detect-alsa-output-capabilities


LANG=C

## TODO: handle non-local mpd
MPD_HOST="${MPD_HOST:-localhost}"
MPD_PORT="${MPD_PORT:-6600}"

MPD_SOCKET="/dev/tcp/${MPD_HOST}/${MPD_PORT}"

MPD_PHONY_URL="mpd://${MPD_HOST}:${MPD_PORT}"

#DEBUG=True
REMOTEURL="https://raw.githubusercontent.com/ronalde/mpd-configure/mpd-monitor"
CMD_ALSACAPS="alsa-capabilities"
ALSACAPS_OUTPUT=""

declare MPD_OUTPUTS

TMPCONFS_TEMPLATE="$(mktemp -u mpdconf.XXXX)"

MSG_MPDCONF="mpd configuration file"
file_samplerate=""
file_sampleencoding=""

alsa_samplerate=""
alsa_sampleencoding=""

### generic functions

function echo_stderr() {
    printf "$@\n" 1>&2; 
}

function die() {
    echo_stderr "\nError: $@"
    exit 1
}

function inform() {
    echo_stderr "(NOTICE: $@)\n"
}

function debug() {
    echo_stderr "DEBUG *** $@"
}

function command_not_found() {
    ## give installation instructions for package $2 when command $1
    ## is not available, optional with non default instructions $3
    ## and exit with error

    command="$1"
    package="$2"
    instructions="${3:-}"
    msg="command \`${command}' not found. "
    if [[ -z "${instructions}" ]]; then
	msg+="Users of Debian and Ubuntu can install it with:\n"
	msg+=" sudo apt-get install ${package}\n"
	msg+="while Arch users can use:\n"
	msg+=" sudo pacman -S ${package}"
    else
	msg+="${instructions}"
    fi
    die "${msg}"

}


function check_commands() {
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 

    CMD_FFPROBE="$(which ffprobe 2>/dev/null)"
    if [[ $? -ne 0 ]]; then
	## try soxi
	CMD_SOXI="$(which soxi 2>/dev/null)"
	if [[ $? -ne 0 ]]; then
	    inform "Neither \`ffprobe' nor the \`soxi' commands where found."
	    die "Install the packages \`ffmpeg' and/or \`sox'."
	fi 
    fi


}


function is_mpd_local() {
    ## determine if mpd is running local, otherwise exit with notice.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 

    loopback_regexp="^127."
    local_ipaddress=""

    msg_remote_intro="Currently the script only functions when mpd runs locally."
    msg_remote_next="It may be run on the specified remote mpd host \`${MPD_HOST}' using ssh, eg"
    msg_remote_ssh="   ssh \${username}@${MPD_HOST} \"bash <(wget -q -O - \"${REMOTEURL}\")\""
    msg_remote_post="(replacing \`\${username}' with the a valid one)"
    msg_remote="$(printf "%s\n%s\n%s\n%s\n" \
"${msg_remote_intro}" "${msg_remote_next}" "${msg_remote_ssh}" "${msg_remote_post}")"

    if [[ -z "${MPD_HOST}" ]]; then
	return 0
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "MPD_HOST is set to \`${MPD_HOST}'" 

	## environment variable is set
	if [[ "${MPD_HOST}" =~ ${loopback_regexp} ]] || \
	       [[  "${MPD_HOST}" = "localhost" ]] ; then
	    ## points to a loopback address
	    return 0
	else
 	    local_ipaddress="$(hostname --ip-addresses)"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "local ip address \`${local_ipaddress}'" 
	    
	    if [[ "${MPD_HOST}" = $(printf "%s" ${local_ipaddress}) ]]; then
		[[ ! -z "${DEBUG}" ]] && \
		    debug "mpd is running local" 
		return 0
	    else
		## assume it is not local
		printf "%s\n" "${msg_remote}"
		return 1
	    fi
	fi
    fi
   
}

function get_mpdconf_filepath() {
    ## check availability if each possible mpd configuration file in
    ## order.  Return full path to the file or empty string on error.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 
    
    for file in $XDG_CONFIG_HOME/mpd/mpd.conf \
		    ~/.mpdconf \
		    ~/.mpd/mpd.conf \
		    /etc/mpd.conf; do
	if [[ -f "${file}" ]]; then
	    [[ ! -z "${DEBUG}" ]] && \
		debug "will use ${MSG_MPDCONF}: \`${file}'."
	    printf "%s" "${file}"
	    break
	fi
    done
}


function get_mpdconf_parameter() {
    ## look up a parameter in the mpd configuration file and return
    ## its value, return an error when not found.
   
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 

    parameter="$1"
    mpdconf_file="${2:-}"
    conf_filter_regexp=""
    
    if [[ -z "${mpdconf_file}" ]]; then
	mpdconf_file="${MPD_CONFIGURATIONFILE}"
    else
	msg="${MSG_MPDCONF} snippet"    
    fi
    
    if [[ ! -f "${mpdconf_file}" ]]; then
	
	die "specified ${msg} \`${mpdconf_file}' \
does not exist or is not accessible"
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "using ${msg} \`${mpdconf_file}'."
    fi

    while read -r line; do
	## lame use of `.' instead of proper escaping single or double quotes
	conf_filter_regexp="${parameter}[[:space:]]*.(.*).$"
	if [[ "${line}" =~ ${conf_filter_regexp} ]]; then
	    value="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "value \`${value}' found for parameter \`${parameter}'."
	fi
    done < "${mpdconf_file}"
    

    if [[ $? -ne 0 ]]; then 
	die "could not extract \`${parameter}' \
from ${msg} \`${mpdconf_file}'."
    else
	## return it 
	printf "%s" "${value}"
    fi
}


function does_mpd_haveoutputs() {
    ## get the defined audio outputs for mpd using the mpd protocol.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    outputname_regexp="outputname:[[:space:]](.*)"
    outputenabled_regexp="outputenabled:[[:space:]]([0-1])"
    mpd_outputs_result="$(execute_mpd_command "outputs")"
    named_output=""

    #debug "${mpd_outputs_result}"
    if [[ $? -ne 0 ]]; then
	printf "%s\n" "error getting outputs from mpd."
	return 1 
    else
	## check if their enabled
	while read -r line; do
	    if [[ -z "${named_output}" ]]; then 
		if [[ "${line}" =~ ${outputname_regexp} ]]; then
		    ## named output found
		    named_output="${BASH_REMATCH[1]}"
		fi
	    else
		## line should indicate if output is enabled
		if [[ ${line} =~ ${outputenabled_regexp} ]]; then
		    if [[ ${BASH_REMATCH[1]} -eq 1 ]]; then
			[[ ! -z ${DEBUG} ]] && \
			    debug "enabled output found: \`${named_output}'."
			## add its name to the array
			MPD_OUTPUTS+=("${named_output}")
		    fi
		    ## reset the loop
		    named_output=""
		    output_found=""
		fi
	    fi
	done<<< "${mpd_outputs_result}"

	if [[ ${#MPD_OUTPUTS[@]} -lt 1 ]]; then 
	    printf "no outputs found"
	    return 1
	else
	    msg="$(printf "\`%s' " "${MPD_OUTPUTS[@]}")"
	    [[ ! -z ${DEBUG} ]] && \
		debug "using outputs: ${msg}"
	    return 0
	fi

    fi
    
}

function get_mpdconf_musicdir() {
    ## extract music_directory from mpd configuration file, and return
    ## it if it's accessible.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 

    msg=""
    mpdconf_parameter="music_directory"
    mpd_musicdir="$(get_mpdconf_parameter "${mpdconf_parameter}")"

    if [[ $? -eq 0 ]]; then 
	msg="trying ${mpdconf_parameter}: \`${mpd_musicdir}' ... "
	if [[ ! -d "${mpd_musicdir}" ]]; then
	    msg+="not accessible."
	    die "${msg}"
	else
	    msg+="done."
	    [[ ! -z "${DEBUG}" ]] && debug "${msg}"	    
	    ## return it 
	    printf "%s" "${mpd_musicdir}"
	fi
    fi
}

function get_mpd_alsa_audio_outputs() {
    ## store configuration snippets in temp files for each alsa
    ## audio_output defined in the mpd configuration.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 
    
    audio_output_started_regexp="audio_output"
    audio_output_ended_regexp="}"
    output_started=""
    audio_output_alsa_type_regexp="(type)[[:space:]]*(alsa)"
    alsa_output_started=""
    output_counter=0
       
    while read -r line; do

	if [[ ! -z "${output_started}" ]]; then 
	    ## inside output?
	    if [[ "${line}" =~ ${audio_output_ended_regexp} ]]; then
		[[ ! -z "${DEBUG}" ]] && \
		    debug "end of audio_output section."
		output_started=""
		continue
	    else
		[[ ! -z "${DEBUG}" ]] && \
		    debug "inside output: \`${line}'."
		## store the line in the temporary config file
		printf "%s\n" "${line}" >> "${tmpconf}"
	    fi
	else   
	    if [[ "${line}" =~ ${audio_output_started_regexp} ]]; then
 		output_started="True"
		## raise the counter and (mis)use the tmpfile
		((output_counter++))
		tmpconf="/tmp/${TMPCONFS_TEMPLATE}.${output_counter}"
		[[ ! -z "${DEBUG}" ]] && \
		    debug "start of audio_output section."
		continue
	    fi
	fi
	
    done < ${MPD_CONFIGURATIONFILE}
    
    if [[ ${output_counter} -gt 0 ]]; then
	[[ ! -z "${DEBUG}" ]] && \
	    debug "${output_counter} alsa output(s) found."
	printf "%s" "${output_counter}"
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "no alsa outputs found."
	return 1
    fi

}

function mpd_handle_staticfilter() {
    ## gracefully handle the case of a static filter in an alsa output
    ## device inside as mpd configuration file.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    mpd_device="$1"
    inform "the alsa output device \`${mpd_device}' is configured for a static format in the ${MSG_MPDCONF}."
    
}

function get_mpd_device() {
    ## extract alsa output device from the temporary configuration
    ## file snippets created with get_mpd_alsa_audio_outputs, and
    ## return it.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    mpd_device=""
    mpd_filter=""
    mpd_fixed_samplerate=""
    mpd_fixed_channelcount=""
    mpd_fixed_sampleencoding=""
    
    alsa_outputs="$(get_mpd_alsa_audio_outputs)"
    if [[ ${alsa_outputs} -lt 1 ]]; then 
	die "no alsa outputs found in the ${MSG_MPDCONF}"
    else 
	for f in /tmp/${TMPCONFS_TEMPLATE}*; do
	    [[ ! -z "${DEBUG}" ]] && \
		debug "reading ${MSG_MPDCONF} snippet \`$f'."
	    while read -r line; do
		[[ ! -z "${DEBUG}" ]] && \
		    debug "line: \`${line}'"
	    done < "${f}" 
	done
    fi
		 
    outputcounter=0
    type_found=""
    alsa_type_found=""
    

    msg=""
    mpdconf_parameter="device"
    for f in /tmp/${TMPCONFS_TEMPLATE}*; do
	mpd_device="$(get_mpdconf_parameter "${mpdconf_parameter}" "${f}")"
	## TODO: handle multiple outputs.
	## for now just stop after the first one.
	if [[ $? -eq 0 ]]; then
	    ## check for a `filter' parameter
	    mpdconf_parameter="filter"
	    mpd_filter="$(get_mpdconf_parameter "${mpdconf_parameter}" "${f}")"
	    if [[ $? -eq 0 ]]; then
		mpd_handle_staticfilter "${mpd_device}"
	    fi
	    break
	fi
    done 
    
    if [[ -z "${mpd_device}" ]]; then
	die "Could not get alsa device from the ${MSG_MPDCONF}."
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "using mpd device \`${mpd_device}'"
	printf "%s" ${mpd_device}
    fi
}


function get_file_samplerate() {
    ## get the sample rate of the file currently played by mpd using soxi
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}'"  

    soxi_output="$1"

    # `Sample Rate    : 44100'
    sr_regexp="Sample Rate[[:space:]]*:[[:space:]]([0-9]*)" 
    
    while read -r line; do 
	if [[ "${line}" =~ ${sr_regexp} ]]; then
	    file_samplerate="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "file_samplerate: \`${file_samplerate}'."
	    printf "%s" "${file_samplerate}"
	fi
    done<<<"${soxi_output}"
}

function parse_file_output() {
    ## parse output from the file command on a wav file.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}'"  

    file_path="$@"
    endianness_raw=""
    endianness=""
    bitdepth=""
    channelcount_raw=""
    channelcount=""
    samplerate=""
    sign="?"

    ## `RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz'
    # 2: 8-64
    regexp_bitdepth="[[:space:]]([0-9]*)[[:space:]]bit"
    # 4: 21000-384000
    regexp_samplerate="[[:space:]]([0-9]*)[[:space:]]Hz"
    # 1: little|big
    regexp_endianness="RIFF[[:space:]]\(([a-z]*)-endian\)[[:space:]]data"
    # 3: stereo|mono
    regexp_channelcount="[[:space:]]([a-z]*)"                             
    wav_regexp="${regexp_endianness},[[:space:]]WAVE[[:space:]]audio,[[:space:]]Microsoft[[:space:]]PCM,${regexp_bitdepth},${regexp_channelcount}${regexp_samplerate}"

    file_info="$(${file_path})"
    while read -r line; do
	if [[ "${line}" =~ ${wav_regexp} ]]; then
	    bitdepth="${BASH_REMATCH[2]}"
	    samplerate="${BASH_REMATCH[4]}"
	    endianness_raw="${BASH_REMATCH[1]}"
	    channelcount_raw="${BASH_REMATCH[3]}"
	    case ${endianness_raw} in
		"little") endianness="L" ;;
		"big")    endianness="B" ;;
		*) die "could not determine endianness of \`${file_path}' using the file command" ;;
	    esac
	    case ${channelcount_raw} in
		"mono") channelcount="1" ;;
		"stereo") channelcount="2" ;;
		*) channelcount="${channelcount_raw}" ;;
	    esac
	    
	    printf "samplerate:%s\n" "${samplerate}"
	    printf "bitdepth:%s\n" "${bitdepth}"
	    printf "endianness:%s\n" "${endianness}"
	    printf "channelcount:%s\n" "${channelcount}"
	    printf "sign:%s\n" "${sign}"
	    
	    break
	fi
    done <<< "${file_info}"
    
}


function get_file_information() {
    ## get the sample encoding and sample rate of the file currently
    ## played by mpd
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}'"  

    file_path="$1"
    file_name=$(basename "${file_path}")
    file_extension="${file_name##*.}"
    file_extension_downcase="${file_extension,,}"
    file_name="${file_name%.*}"

    

    ##          sample rate | bit depth | channels | endianness | sign
    ## file     W   F       | W   F     | W   F    | W          | W            
    ## soxi     W A F       | W A F     | W A F    |            | W A
    ## ffprobe  W A F       | W A F     | W A F    | W A        | W A F             
    
    
    ## file (from coreutils) works great for wav and flac, not for aiff:
    ## wav:  `RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz'
    ## aiff: `IFF data, AIFF audio'.
    ## flac: `FLAC audio bitstream data, 16 bit, stereo, 44.1 kHz'
    ##
    ## ffprobe (from ffmpeg) does the job right for aiff and wav:
    ## wav:  `pcm_s16le ([1][0][0][0] / 0x0001), 44100 Hz, 2 channels, s16, 1411 kb/s'
    ## aiff: `pcm_s24be, 96000 Hz, 2 channels, s32 (24 bit), 4608 kb/s`
    ## flac: `flac, 192000 Hz, stereo, s32 (24 bit)`
    ## 
    ## soxi (from sox) for aiff:
    ## wav:  `Channels : 2 / Sample Rate : 44100 / Precision : 16-bit /
    ##        Sample Encoding : 16-bit Signed Integer PCM'
    ## aiff: `Channels : 2 / Sample Rate : 96000 / Precision : 24-bit /
    ##        Sample Encoding : 24-bit Signed Integer PCM'
    ## flac: `Channels : 2 / Sample Rate : 192000 / Precision: 24-bit /
    ##        Sample Encoding : 24-bit FLAC'
    
    se_regexp="Sample Encoding[[:space:]]*:[[:space:]]([0-9]*)-bit.*"
    
    case ${file_extension_downcase} in
	"wav*"|"flac")
	;;
	
	"aif*")
	;;
	

    
    while read -r line; do 
	if [[ "${line}" =~ ${se_regexp} ]]; then 
	    file_sampleencoding="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "file_sampleencoding: \`${file_sampleencoding}'."
	    printf "%s" "${file_sampleencoding}"
	    
	fi
    done<<<"${soxi_output}"
}


function get_file_sampleencoding() {
    ## get the sample encoding of the file currently played by mpd using soxi
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}'"  

    soxi_output="$1"

    ## examples of soxi output:
    ## `Sample Encoding: 16-bit FLAC',
    ## `Sample Encoding: 24-bit Signed Integer PCM',
    ## or use `Precision      : 16-bit'
    se_regexp="Sample Encoding[[:space:]]*:[[:space:]]([0-9]*)-bit.*"

    ## the file command works great for wav and flac, not for aiff:
    ## wav:  `RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz'
    ## flac: `FLAC audio bitstream data, 16 bit, stereo, 44.1 kHz, 11304888 samples'
    ## aiff: `IFF data, AIFF audio'
    
    while read -r line; do 
	if [[ "${line}" =~ ${se_regexp} ]]; then 
	    file_sampleencoding="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "file_sampleencoding: \`${file_sampleencoding}'."
	    printf "%s" "${file_sampleencoding}"
	    
	fi
    done<<<"${soxi_output}"
}


function get_alsa_samplerate() {
    ## get the properties of the file currently played by mpd using alsa
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    alsa_streamfile="$1"

    ## USB streamfile
    ## Sample rate: Momentary freq = 95999 Hz (0xb.fff8)
    sr_regexp="Momentary freq[[:space:]]=[[:space:]]([0-9]*)[[:space:]]Hz[[:space:]].*"
    ## Any hwparamsfile
    ## rate: 96000 (96000/1)
    sr_regexp="^rate:[[:space:]]([0-9]*)[[:space:]]\(.*\)"
    
    while read -r line; do 
	if [[ "${line}" =~ ${sr_regexp} ]]; then
	    alsa_samplerate="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "alsa_samplerate: \`${alsa_samplerate}'."
	    printf "%s" "${alsa_samplerate}"
	fi
    done<"${alsa_streamfile}"
}


function get_alsa_sampleencoding() {
    ## get the properties of the file currently played by mpd using alsa
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    alsa_streamfile="$1"

    ## USB streamfile
    ## Encoding format: Format: S32_LE
    se_regexp="Format:[[:space:]]([A-Z_0-9]*)" 

    ## Any hwparams file
    ## format: S32_LE
    se_regexp="^format:[[:space:]](.*)"
    
    while read -r line; do 
	if [[ "${line}" =~ ${se_regexp} ]]; then 
	    alsa_sampleencoding="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "alsa_sampleencoding: \`${alsa_sampleencoding}'."
	    printf "%s" "${alsa_sampleencoding}"
	fi
    done<"${alsa_streamfile}"  
}


function get_alsa_streamfile() {
    ## use alsa-capabilities to get the stream file for the (hardware
    ## address of the) alsa interface specified in the mpd
    ## configuration file (needed for `get_alsa_props').
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    #monitor file           =  /proc/asound/card1/stream0
    alsa_streamfile=""
    alsa_streamfile_regexp="monitor[[:space:]]file[[:space:]]*=[[:space:]]*(.*)"
    alsa_hwaddress_value=$(get_mpd_device)
    [[ ! -z "${DEBUG}" ]] && \
	debug "got alsa hwaddress: \`${alsa_hwaddress_value}'"
    
    alsa_hwaddress="${alsa_hwaddress_value/hw:/}"
    alsa_dev_nr="${alsa_hwaddress%%,*}"
    [[ ! -z "${DEBUG}" ]] && \
	debug "using alsa_dev_nr: \`${alsa_dev_nr}'"

    alsa_if_nr="${alsa_hwaddress##*,}"
    [[ ! -z "${DEBUG}" ]] && \
	debug "using alsa_if_nr: \`${alsa_if_nr}'"

    alsa_if_hwparamsfile="/proc/asound/card${alsa_dev_nr}/pcm${alsa_if_nr}p/sub0/hw_params"
    [[ ! -z "${DEBUG}" ]] && \
	debug "alsa_if_hwparamsfile: \`${alsa_if_hwparamsfile}'" 
    
    if [[ ! -f "${alsa_if_hwparamsfile}" ]]; then
	die "alsa_if_hwparamsfile \`${alsa_if_hwparamsfile}' is not accessible."
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "alsa_if_hwparamsfile: \`${alsa_if_hwparamsfile}'."
	## return it to the calling function
	printf "%s" "${alsa_if_hwparamsfile}"
    fi
}

function execute_mpd_command() {
    ## execute a command using the mpd protocol on a pseudo device
    ## file pointing at a mpd host
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    mpd_command="$@"

    ## make file descriptor 5 a read an write copy of the pseudo device file
    ## see: http://www.tldp.org/LDP/abs/html/devref1.html
    exec 5<> ${MPD_SOCKET} 2>/dev/null

    ## quit when connection failed
    if [[ $? -ne 0 ]]; then
	die "Could not connect to ${MPD_PHONY_URL}."
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "connected to ${MPD_PHONY_URL}."
    fi

    ## feed the mpd password to the connection when specified on the
    ## commandline or set as an environment variable
    if [[ ! -z "${MPD_PASS}" ]]; then
	echo "password ${MPD_PASS}" >&5;
    fi
    
    ## send specified mpd_command to mpd's descriptor
    echo "${mpd_command}" >&5
    ## close the connection
    echo "close" >&5
    
    ## read from mpd's descriptor
    mpd_out=$(cat <&5)
    ## return the output to the calling function
    printf "%s" "${mpd_out}"
  
}

function get_mpd_currentsong() {

    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    mpd_currentsong_output="$(execute_mpd_command currentsong)"
    ## file: some/relative/path/song.wav
    mpd_currentsong_regexp="^file:[[:space:]](.*)$"
    while read -r line; do
	if [[ "${line}" =~ ${mpd_currentsong_regexp} ]]; then
	    mpd_currentsong="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_currentsong: \`${mpd_currentsong}'."
	    ## return the relative file name
	    printf "%s" "${mpd_currentsong}"
	    break
	fi
    done <<<"${mpd_currentsong_output}"

}

function get_mpd_samplerate() {

    mpd_status="$@"
    
    #audio: 96000:24:2
    mpd_status_audio_regexp="^audio:[[:space:]]([0-9]*):([0-9]*):([0-9]*)$"
    
    while read -r line; do
	
	if  [[ "${line}" =~ ${mpd_status_audio_regexp} ]]; then
	    ## get properties of audio file currently playing
	    msg="$(printf "%s:%s:%s" ${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]})"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_audio: \`${msg}'"

	    mpd_samplerate="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_samplerate: \`${mpd_samplerate}'"
	    printf "%s" "${mpd_samplerate}"
	    
	fi
    done <<<"${mpd_status}"
}

function get_mpd_bitdepth() {

    msg=""
    mpd_status="$@"
    
    #audio: 96000:24:2
    mpd_status_audio_regexp="^audio:[[:space:]]([0-9]*):([0-9]*):([0-9]*)$"
    
    while read -r line; do
	
	if  [[ "${line}" =~ ${mpd_status_audio_regexp} ]]; then
	    ## get properties of audio file currently playing
	    msg="$(printf "%s:%s:%s" ${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]})"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_audio: \`${msg}'"
	    
	    mpd_bitdepth="${BASH_REMATCH[2]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_bitdepth: \`${mpd_bitdepth}'"
	    ## return the result
	    printf "%s" "${mpd_bitdepth}"
	    
	fi
    done <<<"${mpd_status}"
}

function is_mpd_playing() {
    ## check if mpd is running and playing a file.
    
    mpd_status="$(execute_mpd_command status)"
    
    ## state: stop|play
    state_regexp="state:[[:space:]]([a-z]*)"

    while read -r line; do
	
	if [[ "${line}" =~ ${state_regexp} ]]; then
	    mpd_state="${BASH_REMATCH[1]}"
	    
	    if [[ "${mpd_state}" =~ "stop" ]]; then
		[[ ! -z "${DEBUG}" ]] && \
		    debug "mpd_state: \`${mpd_state}'"
		## exit when state is stopped
		printf "mpd on %s is not playing a file.\n" "${MPD_PHONY_URL}"
		return 1
		break
	    else
		[[ ! -z "${DEBUG}" ]] && \
		    debug "mpd on ${MPD_PHONY_URL} is running and playing a file."
		
	    fi
	fi
    done <<<"${mpd_status}"

}

function get_soxi_props() {

    stored_file_path="$@"
    
    if [[ ! -f "${stored_file_path}" ]]; then
	[[ ! -z "${DEBUG}" ]] && \
	    debug "specified path \`${stored_file_path}' \
is not a file or is not accessible."
	die "specified path \`${stored_file_path}' \
is not a file or is not accessible. Can't continue."
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "checking file: \`${stored_file_path}'."
    fi

}

msg_samplerate="sample rate"
msg_sampleencoding="sample encoding"
msg_source="file on storage"       ## file on storage             < soxi
msg_transfer="transfer by mpd"    ## file as transferred         < mpd
msg_playback="playback by alsa"    ## file as converted to analog < alsa

mpd_state=""
mpd_samplerate=""
mpd_bitdepth=""
mpd_channels=""

## sanity checks

[[ ! -z "${DEBUG}" ]] && \
    debug "start checking sanity ..."

## check if mpd is running local, or exit gracefully
msg_remote="$(is_mpd_local)"
[[ $? -eq 0 ]] || die "${msg_remote}"

## exit when mpd is not playing a file
msg_notplaying="$(is_mpd_playing)"
[[ $? -eq 0 ]] || die "${msg_notplaying}"

## check for audio outputs
msg_nooutputs="$(does_mpd_haveoutputs)"
[[ $? -eq 0 ]] || die "${msg_nooutputs}"

[[ ! -z "${DEBUG}" ]] && \
    debug "... done checking sanity."


mpd_currentsong="$(get_mpd_currentsong)"

## check if soxi command is available; exit with error when
## it is not
check_commands || exit 1

## get the path of the mpd configuration file
MPD_CONFIGURATIONFILE="${MPD_CONFIGURATIONFILE:-}"

if [[ -z "${MPD_CONFIGURATIONFILE}" ]]; then
    MPD_CONFIGURATIONFILE="$(get_mpdconf_filepath)"
fi


## get the path of the hwparams file for the alsa interface from the
## mpd configuration file
alsa_streamfile="$(get_alsa_streamfile)"

## get the path to the (parent) music directory from the mpd
## configuration file
mpd_musicdir="$(get_mpdconf_musicdir)"

## get the path of the current playing song, relative to
## `mpd_musicdir'
stored_file_path="${mpd_musicdir}/${mpd_currentsong}"

## use soxi to determine properties of stored file
file_information="$(get_file_information "${stored_file_path}")"
source_samplerate="$(get_file_samplerate "${file_information}")"
source_sampleencoding="$(get_file_sampleencoding "${file_information}")"

## use mpd to determine properties of transferred file
transfer_samplerate="$(get_mpd_samplerate "${mpd_status}")"
transfer_sampleencoding="$(get_mpd_bitdepth "${mpd_status}")"

playback_samplerate="$(get_alsa_samplerate "${alsa_streamfile}")"
playback_sampleencoding="$(get_alsa_sampleencoding "${alsa_streamfile}")"

printf "Properties of\n\`%s':\n" "${stored_file_path}"

printf " %.0s" {1..22}
printf "%-13s %-13s\n" "${msg_samplerate}" "${msg_sampleencoding}"
printf " %.0s" {1..22}
printf "=%.0s" {1..13}
printf " "
printf "=%.0s" {1..13}
printf "\n"

printf " %-20s %-13s %-13s\n" \
       "${msg_source}" "${source_samplerate}" "${source_sampleencoding}"

printf " %-20s %-13s %-13s\n" \
       "${msg_transfer}" "${transfer_samplerate}" "${transfer_sampleencoding}"

printf " %-20s %-13s %-13s\n\n" \
       "${msg_playback}" "${playback_samplerate}" "${playback_sampleencoding}"

