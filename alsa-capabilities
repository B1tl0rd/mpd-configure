#!/usr/bin/env bash

## This script for linux with bash 4.x displays a list with the audio
## capabilities of each alsa audio output interface and stores them in
## arrays for use in other scripts.  This functionality is exposed by
## the `return_alsa_interface' function which is avaliable after
## sourcing the file. When ran from a shell, it will call that
## function.
##
##  Copyright (C) 2014 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## Source:    https://github.com/ronalde/mpd-configure
## See also:  http://lacocina.nl/detect-alsa-output-capabilities

## an alsa sound card is referred to as a `dev' (device) in this
## script, while an alsa audio output device is referred to as an
## `if' (interface), and within those:
## - `ao' > analog outputs
## - `do' > all (non-usb audio class) digital outputs
## - `uo' > usb audio class digital outputs

LANG=C

APP_NAME_AC="alsa-capabilities"
APP_VERSION="0.4"

## set DEBUG to a non empty value to display internal program flow to
## stderr
DEBUG="${DEBUG:-}"
## set PROFILE to a non empty value to get detailed timing
## information. Normal output is suppressed.
PROFILE="${PROFILE:-}"
## to see how the script behaves with a certain output of aplay -l
## on a particular host, store it's output in a file and supply
## the file path as the value of TESTFILE, eg:
## `TESTFILE=/tmp/somefile ./bash-capabilities
## All hardware and device tests will fail or produce fake outputs
## (hopefully with some grace).
TESTFILE="${TESTFILE:-}"


### generic functions

function echo_stderr() {
    printf "$@\n" 1>&2; 
}

function die() {
    printf "\nError in %s (v%s): %s\n" \
	   "${APP_NAME_AC}" "${APP_VERSION}" "$@" 1>&2;
    exit 1
}

function inform() {
    printf "%s\n" "$@" 1>&2;
}

function debug() {
    printf "DEBUG %s *** %s\n" \
	   "${APP_NAME_AC}" "$@" 1>&2;
}

function command_not_found() {
    ## give installation instructions for package $2 when command $1
    ## is not available, optional with non default instructions $3
    ## and exit with error

    command="$1"
    package="$2"
    instructions="${3:-}"
    msg="command \`${command}' not found. "
    if [[ -z "${instructions}" ]]; then
	msg+="Users of Debian and Ubuntu can install it with:\n"
	msg+=" sudo apt-get install ${package}"
    else
	msg+="${instructions}"
    fi
    die "${msg}"

}


### alsa related functions
function get_aplay_output() {
    ## use aplay to do a basic alsa sanity check and return its (raw)
    ## output to the calling function.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    res=""
    aplay_output=""
    aplay_msg_nosoundcards_regexp="no[[:space:]]soundcards"
    aplay_card_regexp="${1}"

    if [[ ! -z "${TESTFILE}" ]]; then
	if [[ ! -f "${TESTFILE}" ]]; then
	    printf "${MSG_APLAY_ERROR_NOSUCHTESTFILE}" "${TESTFILE}"
	    return 1
	else 
	    ## get the output from a file for testing purposes
	    printf "${MSG_APLAY_USINGTESTFILE}\n" "${TESTFILE}" 1>&2;
	    aplay_output="$(< "${TESTFILE}")"
	    if [[ $? -ne 0 ]]; then
		printf "${MSG_APLAY_ERROR_OPENINGTESTFILE}"
		return 1
	    fi
	fi
    else
    	## run aplay to check for alsa errors
	res="$(${CMD_APLAY} -l 2>&1)"
	## check for alsa errors
	if [[ $? -ne 0 ]]; then
	    printf "${MSG_APLAY_ERROR_GENERAL}\n" "${res}"
	    return 1
	fi
	## check for no soundcards
	if [[ "${res}" =~ ${aplay_msg_nosoundcards_regexp} ]]; then
	    printf "%s\n" "${MSG_APLAY_ERROR_NOSOUNDCARDS}"
	    return 1
	fi
	## run it again without std_err
	aplay_output="$(${CMD_APLAY} -l)"
    fi
    if [[ $? -ne 0 ]]; then
	printf "%s" "${MSG_APLAY_ERROR_UNSPECIFIED}"
	return 1
    else
	printf "%s" "${aplay_output}"
    fi
}

function get_driver() {
    card_nr="$1"
    card_name="card${card_nr}"
    sysclasssound="/sys/class/sound"
    driver=""

    module=$(readlink /sys/class/sound/${card_name}/device/driver/module || return 1)
    driver="${module##*/}"
    printf "%s" "${driver}"

}

function get_codecs() {
    card_nr="$1"
    card_name="card${card_nr}"
    driver="$2"
    driverusb="snd_usb_audio"
    codec_re="^Codec:[[:space:]](.*)$"
    
    if [[ "${driver}" == "${driverusb}" ]]; then
	codecs="N/A"
	printf "%s\n" "${codecs}"
    else
	for codec_file in /proc/asound/${card_name}/codec#*; do
	    while read -r line; do
		if [[ "${line}" =~ ${codec_re} ]]; then 
		    printf "%s\n" "${BASH_REMATCH[1]}"
		    break
		fi
	    done<"${codec_file}"
	done
    fi
}

function get_samplerates_codec() {
    card_nr="$1"
    card_name="card${card_nr}"
    codec_nr="$2"
    codec_file="/proc/asound/${card_name}/codec#${codec_nr}"
    samplerate_re="^rates \[[[:alnum:]]*\]:[[:space:]](.*)$"
    samplerates=""
    
    # rates [0x5f0]: 32000 44100 48000 88200 96000 192000
    for codec_file in /proc/asound/${card_name}/codec#*; do
	while read -r line; do
	    if [[ "${line}" =~ ${samplerate_re} ]]; then 
		samplerates="${BASH_REMATCH[1]// /, }"
		break
	    fi
	done<"${codec_file}"
    done

    printf "codec rates: %s\n" "${samplerates}" 1>&2;
    printf "%s" ${samplerates}
    
}

function get_samplerates_usb() {
    card_nr="$1"
    card_name="card${card_nr}"
    samplerates_re="^[[:space:]]*Rates: (.*)$"
    #Rates: 44100, 48000, 88200, 96000, 176400, 192000
    streamfile="/proc/asound/card${card_nr}/stream0"
    samplerates=""
    
    while read -r line; do
	if [[ "${line}" =~ ${samplerates_re} ]]; then
	    samplerates="${BASH_REMATCH[1]}"
	fi
    done<"${streamfile}"
    printf "usb rates: %s\n" "${samplerates}" 1>&2;
    printf "%s" ${samplerates}
}

function alt_alsa_cards_brm() {
    ## inspired by alsa's scan.sh

    #PS4='+ $(date "+%s.%N")\011 '
    #exec 3>&2 2>/tmp/bashstart.$$.log
    #set -x
 
    card_re="^card([0-9]+)"
    driverusb="snd_usb_audio"
    path="$(pwd)"
    cd /proc/asound || exit 1

    while read -r line; do
	if [[ "${line}" =~ ${card_re} ]]; then
	    codecs=()
	    samplerates=()
	    #list+=(${BASH_REMATCH[1]})
	    card_nr="${BASH_REMATCH[1]}"
	    printf "card number: %s\n" "${card_nr}" 1>&2;
	    driver="$(get_driver "${card_nr}")"
	    printf "driver: %s\n" "${driver}" 1>&2;

	    while read -r codec_line; do
		codecs+=("${codec_line}")
	    done< <(get_codecs "${card_nr}" "${driver}")
	    printf "codecarray: %s\n" "${codecs[@]}" 1>&2;


	    if [[ "${driver}" == "${driverusb}" ]]; then
		samplerates=($(get_samplerates_usb "${card_nr}" "${codeccounter}"))
	    else 
		codeccounter=0
		for codec in "${codecs[@]}"; do
		    samplerates=($(get_samplerates_codec "${card_nr}" "${codeccounter}"))
		    (( codeccounter++ ))
		done
	    fi
	    printf "sampleratearray: %s\n" "${samplerates[@]}" 1>&2;
	    

	fi
    done< <(ls card*)

    #cd "${path}"
    #set +x
    #exec 2>&3 3>&-
}

function handle_doublebrackets() {
    ## return the name of the alsa card / device, even when they
    ## contain brackets.
    
    string="$@"
    [[ ! -z ${DEBUG} ]] && \
	debug "using string: \`${string}'"
    
    bracketcounter=0
    
    for (( i=0; i<${#string}; i++ )); do
	char="${string:$i:1}"
	#printf "." 1>&2;
	if [[ "${char}" = "[" ]]; then
	    (( bracketcounter++ ))
	elif [[ "${char}" = "]" ]]; then
	    (( bracketcounter-- ))
	fi
	if [[ ${bracketcounter} -gt 0 ]]; then
	    ## inside outer brackets
	    if [[ ${bracketcounter} -lt 2 ]] && [[ "${char}" == "[" ]]; then
		[[ ! -z ${DEBUG} ]] && \
		    debug "name with brackets found."
	    else
		printf "${char}"
	    fi
	fi
    done
    
}





function fetch_alsa_outputinterfaces() {
    ## parses each output interface returned by `get_aplay_output'
    ## after filtering (when the appropriate commandline options are
    ## given), stores its capabilities in the appropriate global
    ## indexed arrays and displays them.

    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    msg=""
    aplay_lines=()
    integer_regexp='^[0-9]+$'
    aplay_card_regexp="^card[[:space:]][0-9]+:"
    aplay_output="$(get_aplay_output "${aplay_card_regexp}")"
    ## exit on error
    [[ $? -eq 0 ]] || die "${aplay_output}"
    
    ## reset the counter for interfaces without filtering
    NR_AIFS_BEFOREFILTERING=0

    ## modify the filter for aplay -l when OPT_HWFILTER is set
    if [[ ! -z "${OPT_HWFILTER}" ]]; then
	# the portion without `hw:', eg 0,1 
	alsa_filtered_hwaddr="${OPT_HWFILTER#hw:*}" 
	alsa_filtered_cardnr="${alsa_filtered_hwaddr%%,*}"
	alsa_filtered_devicenr="${alsa_filtered_hwaddr##*,}"
	if [[ ! ${alsa_filtered_cardnr} =~ ${integer_regexp} ]] || \
	   [[ ! ${alsa_filtered_devicenr} =~ ${integer_regexp} ]]; then
	    msg="Invalid OPT_HWFILTER (\`${OPT_HWFILTER}') specified.\n"
	    msg+="Should be \`hw:x,y' were x and y are both integers."
	    die "${msg}"
	fi
	aplay_card_regexp="^card[[:space:]]${alsa_filtered_cardnr}:[[:space:]].*"
	aplay_device_regexp="[[:space:]]device[[:space:]]${alsa_filtered_devicenr}:"
	aplay_card_device_regexp="${aplay_card_regexp}${aplay_device_regexp}"
    else
	aplay_card_device_regexp="${aplay_card_regexp}"
    fi

    ## iterate each line of aplay output
    while read -r line ; do 
	## filter for `^card' and then for `OPT_FILTER' to get matching
	## lines from aplay and store them in an array
	
	if [[ "${line}" =~ ${aplay_card_device_regexp} ]]; then
	    [[ ! -z "${DEBUG}" ]] && \
		debug  "Inspecting interface: ${line}"
	    ## raise the counter for interfaces without filtering
	    let NR_AIFS_BEFOREFILTERING+=1
	    ## check if line matches `OPT_FILTER'
	    if [[ -z "${OPT_FILTER}"  || \
		"$(echo -e "${line}" | grep -E "${OPT_FILTER}")" ]]; then
		[[ ! -z "${DEBUG}" ]] && \
		    debug  "               match: ${line}"
		## store the line in an array
		aplay_lines+=("${line}")
	    fi
	fi
    done <<< "${aplay_output}"

    ## check whether soundcards were found
    if [[ ${#aplay_lines[@]} -lt 1 ]]; then 
	die "${#aplay_lines[@]} soundcards found"
    fi

    ## loop through each item in the array
    for line in "${aplay_lines[@]}"; do 
	## set if type to default (ie analog)
	alsa_if_type="ao"
	## construct bash rematch (brm) regexp for sound device
	## based on aplay.c:
	## printf(_("card %i: %s [%s], device %i: %s [%s]\n"),
	## 1 card,
	## 2 snd_ctl_card_info_get_id(info),
	## 3 snd_ctl_card_info_get_name(info),
	## 4 dev,
	## 5 snd_pcm_info_get_id(pcminfo),
	## 6 snd_pcm_info_get_name(pcminfo));
	## 
	## portion (ie before `,')
	brm_dev="card[[:space:]]([0-9]+):[[:space:]](.*)[[:space:]]\[(.*)\]"
	## same for interface portion
	brm_if=",[[:space:]]device[[:space:]]([0-9]+):[[:space:]](.*)[[:space:]]\[(.*)\]"
	## put together
	brm_template="^${brm_dev}${brm_if}$"

	## unset / empty out all variables
	unset errors
	alsa_dev_nr=""
	alsa_dev_name=""
	alsa_dev_label=""
	alsa_if_nr=""
	alsa_if_name=""
	alsa_if_label=""
	
	errors=()
	## start matching and collect errors in array

	## see if the name contains square brackets, ie it ends with `]]'
	name=""
	alsacard=""
	seperator_start="*##"
	seperator_end="##*"
	name_re="card[[:space:]][0-9]+:[[:space:]](.*)\[.*\[.*\]\].*"
	
	brackets_re="card[[:space:]]([0-9]+):(.*\])\],[[:space:]](device[[:space:]][0-9]+:.*\])"
	if [[ "${line}" =~ ${brackets_re} ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug "#####: line with brackets \`${line}'"
	    if [[ "${line}" =~ ${name_re} ]]; then
		name="${BASH_REMATCH[1]}"
	    [[ ! -z ${DEBUG} ]] && \
		debug "#####: name \`${name}'"		
	    fi
	fi
	if [[ ! -z "${name}" ]]; then
	    if [[ "${line}" =~ ${brackets_re} ]]; then
		## construct string without brackets
		alsacard="$(handle_doublebrackets "${BASH_REMATCH[2]}")"	
		[[ ! -z ${DEBUG} ]] && \
		    debug "#####: alsacard: \`${alsacard}'"		
		
		## replace [ and ] with *
		alsacard="${alsacard//\[/${seperator_start}}"
		alsacard="${alsacard//\]/${seperator_end}}"
		line="card ${BASH_REMATCH[1]}: ${name}[${alsacard}], ${BASH_REMATCH[3]}"
		[[ ! -z ${DEBUG} ]] && \
		    debug "#####: replace line with \`${line}'"
	    fi
	fi
	    
	if [[ "${line}" =~ ${brm_template} ]]; then
	    [[ ! -z "${BASH_REMATCH[1]}" ]] && \
		alsa_dev_nr="${BASH_REMATCH[1]}" || \
		    errors+=("could not fetch device number")
	    [[ ! -z "${BASH_REMATCH[2]}" ]] && \
		alsa_dev_name="${BASH_REMATCH[2]}" || \
		    errors+=("could not fetch device name")
	    [[ ! -z "${BASH_REMATCH[3]}" ]] && \
		alsa_dev_label="${BASH_REMATCH[3]}" || \
		    errors+=("could not fetch device label")
	    [[ ! -z "${BASH_REMATCH[4]}" ]] && \
		alsa_if_nr="${BASH_REMATCH[4]}" || \
		    errors+=("could not fetch interface number")
	    [[ ! -z "${BASH_REMATCH[5]}" ]] && \
		alsa_if_name="${BASH_REMATCH[5]}" || \
		    errors+=("could not fetch interface name")
	    [[ ! -z "${BASH_REMATCH[6]}" ]] && \
		alsa_if_label="${BASH_REMATCH[6]}" || \
		    errors+=("could not fetch interface label")
	    ## consider empty numbers and names of devices and interfaces fatal
	    if [[ -z ${alsa_dev_nr} ]] || \
		   [[ -z ${alsa_dev_name} ]] || \
		   [[ -z ${alsa_if_nr} ]] || \
		   [[ -z ${alsa_if_name} ]]; then
		die "$(prinf "%s\n" "${errors[@]}")"
		break
	    fi

	    if [[ ! -z "${DEBUG}" ]] && [[ "${#errors[@]}" -ne 0 ]]; then
		debug "$(printf "errors: %s\n" "${errors[@]}")"
	    fi

	    alsa_if_hwaddress="hw:${alsa_dev_nr},${alsa_if_nr}"
	    ## construct the path to the character device for the
	    ## interface (ie `/dev/snd/xxx')
	    alsa_if_chardev="/dev/snd/pcmC${alsa_dev_nr}D${alsa_if_nr}p"
	    ## construct the path to the hwparams file
	    alsa_if_hwparamsfile="/proc/asound/card${alsa_dev_nr}/pcm${alsa_if_nr}p/sub0/hw_params"
	    alsa_if_statusfile="/proc/asound/card${alsa_dev_nr}/pcm${alsa_if_nr}p/sub0/status"
	    ## check if the chardev exists
	    if [[ ! -c "${alsa_if_chardev}" ]]; then 
		[[ ! -z "${DEBUG}" ]] && \
		    debug "alsa_if_chardev \`${alsa_if_chardev}' is not a chardev."
		alsa_if_chardev="${alsa_if_chardev} (error: not accessible)"
		alsa_if_formats="(can't determine: character device error)"
		alsa_if_monitorfile="${alsa_if_hwparamsfile} (error: not accessible)"
	    else
		[[ ! -z "${DEBUG}" ]] && \
		    debug "alsa_if_chardev \`${alsa_if_chardev}' is a valid chardev."
		if [[ "$(< ${alsa_if_statusfile})" != "closed" ]]; then
		    ## device is being used, get the lociking pid
		    res="$(get_locking_process "${alsa_if_chardev}")"
		    if [[ $? -ne 0 ]]; then
			## can't determine
			[[ ! -z "${DEBUG}" ]] && \
			    debug "${FUNCNAME}: get_locking_process returned error: \`${res}'"
			
			alsa_if_chardev="${alsa_if_chardev} (is locked by an unknown process; run the script as root or using sudo to see which)"
			alsa_if_formats="(can't determine because device is locked)"
		    else
			if [[ ! -z "${res}" ]]; then
			    alsa_if_chardev="${alsa_if_chardev} ${res}"
			fi
			alsa_if_formats="(error: can't determine)"
			## can determine; get the formats the interface
    			## natively handles or return the process id and
    			## name blocking the interface
		    fi
		else
		    alsa_if_formats="$(return_alsa_formats "${alsa_if_hwaddress}")"
		    if [[ "${alsa_if_formats}" == "${MSG_DEVICE_BUSY}" ]]; then
			alsa_if_formats="(error: can't determine because device is in use)"
		    fi
		fi
		    

	    fi

	    ## check if the hwparams file exists
	    if [[ ! -f "${alsa_if_hwparamsfile}" ]]; then
		alsa_if_hwparamsfile="${alsa_if_hwparamsfile} (error: not accessible)"
	    fi

	    ## before determining whether this is a usb device, assume
	    ## the monitor file is the hwparams file
	    alsa_if_monitorfile="${alsa_if_hwparamsfile}"

	    ## check if the interface name matches one of the strings
	    ## in the digital filter array
	    for filter in "${DO_INTERFACE_FILTER[@]}"; do
		## `,,' downcases the string, while `*var*' does a wildcard match
		if [[ "${alsa_if_name,,}" == *"${filter}"* ]]; then
		    [[ ! -z "${DEBUG}" ]] && debug "match = ${alsa_if_name,,}: ${filter}"
		    ## set ao type to d(igital)o(out)
		    alsa_if_type="do"
		    ## exit this for loop
		    break
		fi
	    done

	    ## try to get the stream file for the interface (ie
	    ## `/proc/asound/cardX/streamY'); such determines whether
	    ## its a uac device, and if so, which class it is
	    alsa_streamfile="/proc/asound/card${alsa_dev_nr}/stream${alsa_if_nr}"
	    msg_alsa_streamfile="alsa_streamfile \`${alsa_streamfile}'"
	    if [[ ! -f "${alsa_streamfile}" ]] ;then
		[[ ! -z ${DEBUG} ]] && \
		    debug "${msg_alsa_streamfile} ${MSG_ERROR_NOFILE}"
		## no uac interface
		alsa_if_uacclass="${MSG_PROP_NOTAVAILABLE}"
	    else
		[[ ! -z ${DEBUG} ]] && \
		    debug "${msg_alsa_streamfile} is an accessible file."
		## set interface to usb out
		alsa_if_type="uo"
		## uac devices will use the stream file instead of
		## hwaparams file to monitor
		alsa_if_monitorfile="${alsa_streamfile}"
		## get the type of uac endpoint
		alsa_if_uac_ep="$(return_alsa_uac_ep "${alsa_streamfile}")"
		if [[ $? -ne 0 ]]; then    
		    alsa_if_uacclass="${MSG_PROP_NOTAVAILABLE}"
		    alsa_if_uacclass_nr="?"
		    alsa_if_uacclass_label="${MSG_PROP_NOTAVAILABLE}"
		else
		    [[ ! -z ${DEBUG} ]] && \
			debug "alsa_if_uac_ep set to \`${alsa_if_uac_ep}'."		    
		    ## lookup the uac class in the array for this type of endpoint (EP)
		    ## (for readability)
		    alsa_if_uacclass="${UO_EP_LABELS[${alsa_if_uac_ep}]}"
		    ## the uac class number (0, 1, 2 or 3) according to ./sound/usb/card.h
		    alsa_if_uacclass_nr="${alsa_if_uacclass% - *}"
		    classnr_regexp='^[0-3]+$'
		    if [[ ! ${alsa_if_uacclass_nr} =~ ${classnr_regexp} ]]; then
			[[ ! -z ${DEBUG} ]] && \
			    debug "invalid uac class number \`${alsa_if_uacclass_nr}'. \
${MSG_ERROR_UNEXPECTED}"
			alsa_if_uacclass_nr="?"
		    fi
		    ## the uac label (ie everything after `x: ')
		    alsa_if_uacclass_label="${alsa_if_uacclass:4}"
		fi
	    fi
	fi

	## for each type of interface, store a `hardware address' and
	## `monitoring file' pair in the proper array and construct
	## the display title
	case "${alsa_if_type}" in
	    "ao")
		## only if neither `OPT_LIMIT_DO' and `OPT_LIMIT_UO' are set
		[[ ! -z ${OPT_LIMIT_DO} || ! -z ${OPT_LIMIT_UO} ]] && \
		    continue || match="true"
		;;
	    "do")
		## only if neither `OPT_LIMIT_AO' and `OPT_LIMIT_UO' are set
		[[ ! -z ${OPT_LIMIT_AO} || ! -z ${OPT_LIMIT_UO} ]] && \
		    continue || match="true"
		;;
	    "uo")
		## only if `OPT_LIMIT_AO' is not set
		[[ ! -z ${OPT_LIMIT_AO} ]] && \
		    continue || match="true"
	esac

	if [[ ! -z "${match}" ]]; then

	    alsa_if_title_label="${ALSA_IF_LABELS[${alsa_if_type}]}"
	    if [[ "${alsa_dev_label}" =~ .*${seperator_start}.* ]]; then
		alsa_dev_label="${alsa_dev_label//\*##/\[}"
		alsa_dev_label="${alsa_dev_label//##\*/\]}"
	    fi
	

	    ## construct the display title
	    alsa_if_display_title=$(printf " %s) %s \`%s'" \
					   "${#ALSA_AIF_HWADDRESSES[@]}" \
					   "${alsa_if_title_label}" \
					   "${alsa_if_hwaddress}")

	    ## store the details of the current interface in global arrays
	    ALSA_AIF_HWADDRESSES+=("${alsa_if_hwaddress}")
	    ALSA_AIF_MONITORFILES+=("${alsa_if_monitorfile}")
	    ALSA_AIF_DISPLAYTITLES+=("${alsa_if_display_title}")
	    ALSA_AIF_DEVLABELS+=("${alsa_dev_label}")
	    ALSA_AIF_LABELS+=("${alsa_if_label}")
	    ALSA_AIF_UACCLASSES+=("${alsa_if_uacclass}")
	    ALSA_AIF_FORMATS+=("${alsa_if_formats}")
	    ALSA_AIF_CHARDEVS+=("${alsa_if_chardev}")
	fi

	#alsa_if_samplerates="$(return_alsa_samplerates \
#"${alsa_dev_nr}" "${alsa_if_nr}" "${alsa_if_type}" "${alsa_if_label}")"
#	if [[ $? -ne 0 ]]; then
#	    [[ ! -z ${DEBUG} ]] && \
#		debug "error getting samplerates"
#	else
#	    [[ ! -z ${DEBUG} ]] && \
#		debug "alsa_if_samplerates: \`${alsa_if_samplerates}'."
#	fi
	
	## construct a list with the properties of the current
	## interface if `OPT_QUIET' is not set
	msg_alsa_devname="device name"
	msg_alsa_codecname="codec name"
	msg_alsa_ifname="interface name"
	msg_alsa_uacclass="usb audio class"
	msg_alsa_chardev="character device"
	msg_alsa_encodingformats="encoding formats"
	msg_alsa_packingformats="packing formats"
	msg_alsa_samplerates="sample rates"
	msg_alsa_monitorfile="monitor file"
	
	if [[ -z "${OPT_QUIET}" ]]; then
	    printf "%s\n" "${alsa_if_display_title}" 1>&2;
	    printf " - %-17s = %-60s\n" "${msg_alsa_devname}" "${alsa_dev_label}" 1>&2;
	    printf " - %-17s = %-60s\n" "${msg_alsa_ifname}" "${alsa_if_label}" 1>&2;
	    printf " - %-17s = %-60s\n" "${msg_alsa_uacclass}" "${alsa_if_uacclass}" 1>&2;
	    printf " - %-17s = %-60s\n" "${msg_alsa_chardev}" "${alsa_if_chardev}" 1>&2;
	    printf " - %-17s = %-60s\n" "${msg_alsa_encodingformats}" "${alsa_if_formats}" 1>&2;
	    printf " - %-17s = %-60s\n" "${msg_alsa_monitorfile}" "${alsa_if_monitorfile}" 1>&2;
	    printf "\n"
	fi

    done

}

function get_locking_process() {
    ## get the pid and name of the process accessing chardev $1, which
    ## may be a file or a socket. Returns a descriptive string or a notice with error.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    chardev_path="$1"
    ## try fuser which returns the pid in std_out.
    res="$(${CMD_FUSER} -v ${chardev_path} 2>&1)"
    if [[ $? -ne 0 ]]; then
	## real error; return it to calling function
	printf "%s" "${res}"
	return 1
    else   
	[[ ! -z ${DEBUG} ]] && \
	    debug "${FUNCNAME}: \`${chardev_path}' is accessible"
	## is in use, run again without v to get the pid
	## fetch the process name
	pnamepid=$(ps o cmd=,pid=$(${CMD_FUSER} ${chardev_path} 2>/dev/null))
	res="$?"
	## TODO: pnamedpid is always empty (2>/dev/null)
	[[ ! -z ${DEBUG} ]] && \
	    debug "${FUNCNAME}: \`${chardev_path}' is in use; ps returned: \`${pnamepid}"
	if [[ ${res} -ne 0 ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME}: ps returned error \`${res}'"
	    printf "ps returned error \`%s'" "${res}"
	    return 1
	else
	    if [[ -z ${pnamepid} ]]; then
		## process not found
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME}: ps returned no error and no processes"
		printf "ps found no processess"
		return 1
	    else
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME}: ps returned \`${pnamepid}'"
		pname="${pnamepid// *}" # return anything before the space
		pid="${pnamepid//* }"
		## return the formatted string
		printf "(in use by \`%s' with pid \`%s')" "$(basename ${pname})" "${pid}"
	    fi
	fi

    fi
}

function return_alsa_samplerates() {
    ## fetch and return a comma separated string of playback sample
    ## rates for the card specified by its cardnr in $1, device number
    ## in $2 and type in $3.
    
    [[ ! -z ${DEBUG} ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    #non-uac: "rates" in /proc/asound/cardx/codec#0
    #uac:     "Rates" in /proc/asound/cardx/stream0
    
    alsa_dev_nr="$1"
    alsa_if_nr="$2"
    ## uo = uac, else non-uac
    alsa_if_type="$3"
    alsa_if_name="$4"
    samplerates=""
    rates_file=""
    
    if [[ "${alsa_if_type}" == "uo" ]]; then 
	rates_regexp="Rates:[[:space:]](.*)$"
	rates_file="/proc/asound/card${alsa_dev_nr}/stream${alsa_if_nr}"
    else
	rates_regexp="rates[[:space:]]\[[0-9a-z]*\]:[[:space:]](.*)$"
	rates_file="/proc/asound/card${alsa_dev_nr}/codec#${alsa_if_nr}"
    fi 

    if [[ ! -f "${rates_file}" ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    debug "invalid ${rates_file}: \`${rates_file}'."
	return 1
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug "using rates_file \`${rates_file}' and rates_regexp \`${rates_regexp}'"
	while read -r line; do
	    #debug "line: ${line}"
	    if [[ "${line}" =~ ${rates_regexp} ]]; then
		debug "matching line: ${line}"
		samplerates="${BASH_REMATCH[1]}"
		break
	    fi
	    
	done<"${rates_file}"
    fi
    if [[ -z "${samplerates}" ]]; then
	## some error
	return 1
    else 
	if [[ ! "${alsa_if_type}" == "uo" ]]; then 
	    ## replace spaces with `, '
	    samplerates="${samplerates// /, }"
	fi
	printf "${samplerates}"
    fi
   
}

function return_alsa_formats() {
    ## fetch and return a comma separated string of playback
    ## formats by feeding aplay dummy input (--format=MPEG) while
    ## making sure the test is silent by redirecting output to
    ## /dev/null.
    ## 
    ## needs address of alsa output device in `hw:x,y' format 
    ## as single argument ($1)
    [[ ! -z ${DEBUG} ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    alsa_hw_device="$1"
    aplay_opts=(-D ${alsa_hw_device})
    aplay_opts+=(-f MPEG)
    format=""
    pseudo_random="30985218341569576428057261168568123489906994"

    ## throw psuedo random but non-audio data to aplay to determine formats
    aplay_out="$(echo ${pseudo_random} | \
LANG=C ${CMD_APLAY} ${aplay_opts[@]} 2>&1 >/dev/null | grep '^- ')"
    while read -r line; do 
	format="${format}, ${line/- /}"
    done <<< "${aplay_out}"
    formats="${format#, }"
    [[ ! -z "${formats}" ]] && \
	printf "${formats}" || printf "${MSG_DEVICE_BUSY}"

}


function return_alsa_uac_ep() {
    ## returns/echoes the usb audio class endpoint as a fixed number.
    ## needs path to stream file as single argument ($1)
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"
    
    ## based on ./sound/usb/proc.c:
    ##  printf "    Endpoint: %d %s (%s)\n",
    ##   1: fp->endpoint & USB_ENDPOINT_NUMBER_MASK (0x0f) > [0-9]
    ## TODO: unsure which range this is; have seen 1, 3 and 5
    ##   2: USB_DIR_IN: "IN|OUT",
    ##   3: USB_ENDPOINT_SYNCTYPE: "NONE|ASYNC|ADAPTIVE|SYNC"
  
    alsa_streamfile_path="$1"
    ep_mode=""
    ep_label_filter="Endpoint:"
    ep_label_regexp="^[[:space:]]*${ep_label_filter}"
    ep_num_filter="([0-9]+)"                         #1
    ep_num_regexp="[[:space:]]${ep_num_filter}"
    ep_direction_filter="OUT"
    ep_direction_regexp="[[:space:]]${ep_direction_filter}"
    ep_synctype_filter="(${UO_EP_NONE_FILTER}|${UO_EP_ADAPT_FILTER}|${UO_EP_ASYNC_FILTER}|${UO_EP_SYNC_FILTER})"                                   #2
    ep_synctype_regexp="[[:space:]]\(${ep_synctype_filter}\)$"
    ep_regexp="${ep_label_regexp}${ep_num_regexp}${ep_direction_regexp}${ep_synctype_regexp}"

    [[ ! -z ${DEBUG} ]] && \
	debug "ep_regexp: \`${ep_regexp}'"
    ## iterate the contents of the streamfile
    while read -r line; do
	if [[ "${line}" =~ ${ep_regexp} ]]; then
	    ep_mode="${BASH_REMATCH[2]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "matching endpoint found in line \`${line}': \`${ep_mode}'."
	    break
	fi
    done<"${alsa_streamfile_path}"

    if [[ -z "${ep_mode}" ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    debug "no matching endpoints found. ${MSG_ERROR_UNEXPECTED}"
	printf ""
	return 1
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug "return_alsa_uac_ep returned value: \`${ep_mode}'."
	## return the filtered endpoint type
	printf "%s" "${ep_mode}"
    fi

}


### command line parsing

function analyze_opt_limit() {
    ## check if the argument for the `-l' (limit) option is proper

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$*'"

    opt_limit="$1"
    case ${opt_limit} in
        a|analog) 
	    OPT_LIMIT_AO="True"
	    [[ ! -z "${DEBUG}" ]] && debug "OPT_LIMIT_AO set to \`${OPT_LIMIT_AO}'"
	    return 0
	    ;;
        u|usb|uac) 
	    OPT_LIMIT_UO="True"
	    [[ ! -z "${DEBUG}" ]] && debug "OPT_LIMIT_UO set to \`${OPT_LIMIT_UO}'"
	    return 0
	    ;;
        d|digital)
	    OPT_LIMIT_DO="True"
	    [[ ! -z "${DEBUG}" ]] && debug "OPT_LIMIT_DO set to \`${OPT_LIMIT_DO}'"
	    return 0
	    ;;
	*)
	    args=$(printf "\"%s\", " "${OPT_LIMIT_ARGS[@]}")
	    die "the \`-l' (limit) option requires one of the following arguments:\
\n${args%*, }"
    esac
}


function display_usageinfo() {
    ## display syntax and exit

    msg=$(cat <<EOF
Usage:
$0 [ -l a|d|u ]  [ -c <filter> ] [-a <hwaddress>] [ -q ]

Displays a list of alsa audio output interfaces with their details and
ends with the hardware address (\`hw:x,y') for the first available
interface. When the \`-q (quiet)' option is set, the list is
surpressed, ie only the hardware address is displayed.

The list may be filtered by using the limit option \`-l' with an
argument, either \`a' (or \`analog'), \`d' (or \`digital') or \`u' (or
\`usb' or \`uac') to only show interfaces fitting that limit. In
addition, a custom filter may be specified as an argument for the \`c'
option.

The \`a' option is for usage in scripts, and expects a valid alsa
hardware address (eg. hw:0,1).

Returns 0 if an interface is available or 1 in case of no matches.

  -l a | analog     Limit the interfaces to analog ones.
  -l u | usb | uac  Limit the available output devices to those that
                    support USB Audio Class.
  -l d | digital    Limit the available interfaces to digital ones using
                    a static (and arbitrary) filter.
  -c <regexp>       Limit the available interfaces further to match
                    \`<regexp>'.
  -a <hwaddress>    Limit the returned interface to the one specified with 
                    \`<hwaddress>', eg. hw:0,1
  -q, --quiet       Surpress listing each interface with its details,
                    ie only store the details of each card in the
                    appropriate arrays.
  -h, --help        Show this help message
EOF
)
    inform "${msg}"
    exit 1
}

function analyze_command_line() {
    ## parse command line arguments using bash getopts

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$*'"

    ## put characters in the array in a string
    shortopts=":${SHORT_OPTS[@]/ /}"

    while getopts "${shortopts}" option; do
        case "$option" in
            l) 
		[[ ! -z "${DEBUG}" ]] && \
		    debug "option \`l' (${OPTIND}): \`${option}' set to \`${OPTARG}'"
		OPT_LIMIT="True"
		analyze_opt_limit "${OPTARG}"
		;;
            q)
		[[ ! -z "${DEBUG}" ]] && \
		    debug "option \`q' (${OPTIND}): \`${option}' set to \`${OPTARG}'"
		OPT_QUIET=true
		;;
            c) 
		[[ ! -z "${DEBUG}" ]] && \
		    debug "option \`c' (${OPTIND}): \`${option}' set to \`${OPTARG}'"
		OPT_FILTER="${OPTARG}"
		;;
            a) 
		[[ ! -z "${DEBUG}" ]] && \
		    debug "option \`a' (${OPTIND}): \`${option}' set to \`${OPTARG}'"
		OPT_HWFILTER="${OPTARG}"
		;;
           h|\?) 
		done_opts=true
		display_usageinfo
		;;
            *) 
		[[ ! -z "${DEBUG}" ]] && \
		    debug "option \`other' (${OPTIND}): \`${option}' set to \`${OPTARG}'"
		done_opts=true
		display_usageinfo
        esac
    done
}

function return_alsa_interface() {
    ## main function; see display_usageinfo()

    profile_file=""
    ## start profiling
    if [[ ! -z ${PROFILE} ]]; then
	profile_file="/tmp/alsa-capabilities.$$.log"
	PS4='+ $(date "+%s.%N")\011 '
	exec 3>&2 2>${profile_file}
	set -x
    fi

    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    ## check if needed commands are available
    CMD_APLAY=$(which aplay || command_not_found "aplay" "alsa-utils")
    if [[ $? -ne 0 ]]; then
	die "The script cannot continue without aplay."
    fi
    CMD_FUSER=$(which fuser || command_not_found "fuser" "psmisc")

    ## parse command line arguments
    analyze_command_line "$@"

    if [[ ! -z ${OPT_STOP_PULSEAUDIO} ]] || \
	   [[ ! -z ${OPT_DISABLE_PULSEAUDIO} ]]; then 
	## analyse pulseaudio when requested
	if [[ ! -f pulseaudio-helper ]]; then
	    inform "option \`OPT_STOP_PULSEAUDIO' and/or OPT_DISABLE_PULSEAUDIO are set, but helper script \`pulseaudio-helper' not found."
	else
	    source pulseaudio-helper
	    pulseaudio_evaluate_stopping
	fi
    fi
    ## create a list of alsa audio output interfaces and parse it.
    fetch_alsa_outputinterfaces

    if [[ ! -z ${OPT_STOP_PULSEAUDIO} ]] || \
	   [[ ! -z ${OPT_DISABLE_PULSEAUDIO} ]]; then 
	## restore and restart pulseaudio if requested and command available.
	pulseaudio_evaluate_restoring
    fi

    ## exit with error if no matching output line was found
    if [[ ${#ALSA_AIF_HWADDRESSES[@]} == 0 ]]; then
	msg="\n${MSG_MATCH_IF_NONE_UNLIMITED}"
	##  display information about the number of interfaces before filtering
	[[ ! ${NR_AIFS_BEFOREFILTERING} == 0 ]] && \
	    msg=$(printf "${MSG_MATCH_IF_NONE_LIMITED}"  "${NR_AIFS_BEFOREFILTERING}")
	inform "\n${msg}"
    fi
    
    [[ ! -z "${DEBUG}" ]] && \
	debug "Number of audio interfaces after filtering: ${#ALSA_AIF_HWADDRESSES[@]}"

    if [[ ! -z ${PROFILE} ]]; then 
	## end profiling
	set +x
	exec 2>&3 3>&-
	debug "Profiling information stored in: ${profile_file}"
    fi

    ## return success if interfaces are found
    return 0
    

}

### global variables

## indexed arrays to store the details of interfaces of one would
## declare such an array in another script, that array would be filled
## instead of these. See examples/bash-example.sh for usage.
set +u 

[[ -z ${ALSA_AIF_HWADDRESSES} ]] && declare -a ALSA_AIF_HWADDRESSES=()
[[ -z ${ALSA_AIF_DISPLAYTITLES} ]] && declare -a ALSA_AIF_DISPLAYTITLES=()
[[ -z ${ALSA_AIF_MONITORFILES} ]] && declare -a ALSA_AIF_MONITORFILES=()
[[ -z ${ALSA_AIF_DEVLABELS} ]] && declare -a ALSA_AIF_DEVLABELS=()
[[ -z ${ALSA_AIF_LABELS} ]] && declare -a ALSA_AIF_LABELS=()
[[ -z ${ALSA_AIF_UACCLASSES} ]] && declare -a ALSA_AIF_UACCLASSES=()
[[ -z ${ALSA_AIF_FORMATS} ]] && declare -a ALSA_AIF_FORMATS=()
[[ -z ${ALSA_AIF_CHARDEVS} ]] && declare -a ALSA_AIF_CHARDEVS=()

set -u

## counter for unfiltered interfaces
NR_AIFS_BEFOREFILTERING=0

## static filter for digital interfaces
DO_FILTER_LIST="$(cat <<EOF
adat
aes
ebu
digital
dsd
hdmi
i2s
iec958
spdif
s/pdif
toslink
uac
usb
EOF
    )"

declare -a DO_INTERFACE_FILTER=($(printf -- '%s' "${DO_FILTER_LIST// /" "}"))

## construction for displayed output 
UAC="USB Audio Class"
ALSA_IF_LABEL="alsa audio output interface"
declare -A ALSA_IF_LABELS=()
ALSA_IF_LABELS+=(["ao"]="Analog ${ALSA_IF_LABEL}")
ALSA_IF_LABELS+=(["do"]="Digital ${ALSA_IF_LABEL}")
ALSA_IF_LABELS+=(["uo"]="${UAC} ${ALSA_IF_LABELS[do]}")
ALSA_NON_DO_IF="${ALSA_IF_LABELS[ao]}"
ALSA_NON_UO_IF="Non-UAC ${ALSA_IF_LABELS[do]}"


## USB_SYNC_TYPEs
## strings alsa uses for UAC endpoint descriptors.
## one of *sync_types "NONE", "ASYNC", "ADAPTIVE" or "SYNC" according
## to ./sound/usb/proc.c
UO_EP_NONE_FILTER="NONE"
UO_EP_ADAPT_FILTER="ADAPTIVE"
UO_EP_ASYNC_FILTER="ASYNC"
UO_EP_SYNC_FILTER="SYNC"
## labels for UAC classes.
UO_EP_NONE_LABEL="0 - (none)"
UO_EP_ADAPT_LABEL="1 - isochronous adaptive"
UO_EP_ASYNC_LABEL="2 - isochronous asynchronous"
UO_EP_SYNC_LABEL="3 - sync (?)"
## declarative array holding the available UAC classes with
## description
declare -A UO_EP_LABELS=( ["${UO_EP_NONE_FILTER}"]="${UO_EP_NONE_LABEL}" 
			  ["${UO_EP_ADAPT_FILTER}"]="${UO_EP_ADAPT_LABEL}" 
			  ["${UO_EP_ASYNC_FILTER}"]="${UO_EP_ASYNC_LABEL}" 
			  ["${UO_EP_SYNC_FILTER}"]="${UO_EP_SYNC_LABEL}" )

## system messages
MSG_PROP_NOTAPPLICABLE="(n/a)"
MSG_PROP_NOTAVAILABLE="(none)"
MSG_DEVICE_BUSY="can't detect"
MSG_ERROR_NOFILE="is not a file or is not accessible."
MSG_ERROR_UNEXPECTED="THIS SHOULD NOT HAPPEN."
MSG_RUN_AS_ROOT="device in use, run as root to display process."
MSG_APLAY_ERROR_NOSOUNDCARDS="aplay did not find any soundcard."
MSG_APLAY_ERROR_GENERAL="aplay reported the following error:\n\`%s'"
MSG_APLAY_ERROR_UNSPECIFIED="aplay returned no results."
MSG_APLAY_USINGTESTFILE="NOTICE: using fake aplay output stored in TESTFILE: \`%s'."
MSG_APLAY_ERROR_NOSUCHTESTFILE="Specified TESTFILE \'%s' does not exist."
MSG_APLAY_ERROR_OPENINGTESTFILE="Error opening TESTFILE \'%s'."
MSG_NO_DEVICE="no such device"
MSG_NO_FILE="no such file"
MSG_TAB=" * "
MSG_MARGIN="${MSG_TAB//\*/ }"
MSG_MATCH_IF_NONE_UNLIMITED="${MSG_TAB}No ${ALSA_IF_LABEL}s found."
MSG_MATCH_IF_NONE_LIMITED="${MSG_TAB}From the %s available ${ALSA_IF_LABEL}s, \
none matched your filter."

## command line options
### optional input parameters, the ones with `:' need an argument
declare -a OPT_LIMIT_ARGS=("a" "analog" "d" "digital" "u" "usb" "uac")
SHORT_OPTS=("l:" "c:" "a:" "q" "h")

OPT_FILTER="${OPT_FILTER:-}"
OPT_HWFILTER="${OPT_HWFILTER:-}"

OPT_LIMIT_AO=${OPT_LIMIT_AO:-}
OPT_LIMIT_DO=${OPT_LIMIT_DO:-}
OPT_LIMIT_UO=${OPT_LIMIT_UO:-}
OPT_QUIET=${OPT_QUIET:-}
OPT_FILTER=${OPT_FILTER:-}
OPT_HWFILTER=${OPT_HWFILTER:-}

## currently unused
OPT_STOP_PULSEAUDIO="${OPT_STOP_PULSEAUDIO:-}"
OPT_DISABLE_PULSEAUDIO="${OPT_DISABLE_PULSEAUDIO:-}"

## if the script is not sourced by another script but run within its
## own shell call function `return_alsa_interface'
[[ "${BASH_SOURCE[0]:-}" != "${0}" ]] || return_alsa_interface "$@"

